{"version":3,"sources":["../src/__prologue__.js","../src/utilities.js","../src/Element.js","../src/Problem.js","../src/Metaheuristic.js","../src/metaheuristics/DistributionEstimation.js","../src/metaheuristics/HillClimbing.js","../src/metaheuristics/GeneticAlgorithm.js","../src/metaheuristics/BeamSearch.js","../src/metaheuristics/SimulatedAnnealing.js","../src/metaheuristics/ParticleSwarm.js","../src/metaheuristics/DifferentialEvolution.js","../src/metaheuristics/EvolutionStrategy.js","../src/metaheuristics/HarmonySearch.js","../src/metaheuristics/GradientDescent.js","../src/problems/HelloWorld.js","../src/problems/testbeds.js","../src/problems/NQueensPuzzle.js","../src/problems/KnapsackProblem.js","../src/problems/associationRules.js","../src/__epilogue__.js"],"names":["__init__","base","Sermat","declare","iterable","initialize","raise","raiseIf","Events","Future","Iterable","Logger","Randomness","Statistics","exports","__package__","__name__","__dependencies__","__SERMAT__","include","metaheuristics","problems","utilities","clamp","value","min","max","Math","emblemHan","element","evaluation","map","e","isNaN","round","join","encodeHan","values","v","END_CJK","END_HANGUL","String","fromCharCode","decodeHan","string","split","chr","charCodeAt","Element","constructor","this","__values__","checkValues","randomValues","property evaluation","get","__evaluation__","set","Array","isArray","ArrayType","Uint32Array","prototype","slice","call","model","repeat","n","toArray","randomValue","i","problem","random","randomInt","coerce","suffices","sufficientElement","emblem","evaluate","elem","then","hammingDistance","array1","array2","count","len","length","manhattanDistance","sum","abs","euclideanDistance","pow","sqrt","rootMeanSquaredError","f","data","error","datum","apply","isBetterThan","other","compare","neighbourhood","radius","neighbours","d","push","modification","newValues","arguments","mapping","rangeMapping","args","lastRange","rangeTo","normalizedValues","arrayMapping","lastItems","items","floor","setMapping","full","result","index","splice","clone","equals","toString","ser","static __SERMAT__","identifier","serializer","obj","materializer","Problem","params","ignore","object","array","func","objective","objectives","elementModel","title","description","DEFAULT","Infinity","elements","reevaluate","async","filter","__isFuture__","all","sufficientElements","element1","element2","singleObjectiveComparison","paretoComparison","value1","value2","values1","values2","worse","better","zip","mapApply","r","domination","NaN","__params__","self","forEach","id","Metaheuristic","logger","ROOT","defaultValue","number","integer","events","__log__","level","initiate","size","state","onInitiate","update","mh","expand","sieve","onUpdate","expansion","concat","onExpand","expansionRate","elems","evalTime","statistics","stat","key","startTime","results","sort","addTime","onEvaluate","multiObjectiveSort","bind","reverse","onSieve","finished","step","steps","analyze","stat_evaluation","add","stats_evaluation","_","stat_dominators","stat_dominated","pareto","dominators","dominated","onAnalyze","advance","stepTime","reset","onAdvance","run","doWhile","onFinish","nub","precision","e1","e2","emit","paretoAnalysis","i1","i2","elem1","elem2","nonDominatedSort","crowdingDistance","j","es","strengthParetoSort","strength","dominator","name","hasOwnProperty","DistributionEstimation","HillClimbing","localOptima","range","delta","best","__localOptima__","atLocalOptima","GeneticAlgorithm","minimum","maximum","selections","rankSelection","crossovers","singlepointCrossover","mutations","singlepointUniformMutation","parents","childs","child","newElements","selection","crossover","randomBool","mutationRate","mutation","static selections","randoms","selected","x","y","shift","rouletteSelection","evaluationStat","stochasticUniversalSamplingSelection","p","select","iterate","pointer","static crossovers","cut","values0","twopointCrossover","cut1","cut2","uniformCrossover","elementLength","choice","static mutations","uniformMutation","maxPoints","times","singlepointBiasedMutation","recombinationMutation","v1","BeamSearch","successors","allSuccessors","SimulatedAnnealing","coolingSchedule","linear","randomNeighbour","acceptance","current","neighbour","temp","temperature","exp","maximumTemperature","minimumTemperature","acceptanceStat","ParticleSwarm","__velocity__","__localBest__","nextVelocity","globalBest","velocity","localBest","localCoef","localAcceleration","globalCoef","globalAcceleration","inertia","nextElement","nextValues","__globalBest__","DifferentialEvolution","elementIndex","stateCopy","choices","a","b","c","randomIndex","crossoverProbability","differentialWeight","EvolutionStrategy","mutant","mutants","mutantCount","HarmonySearch","harmonyProbability","adjustProbability","histograms","elementFromHistograms","histogramWidth","static histograms","histogramCount","counts","bar","static elementFromHistograms","histogram","static histogramProblem","HistogramProblem","when","evaluations","GradientDescent","gradient","gradientFiniteDifferences","rate","estimatorWidth","gradientValue","width","left","right","leftEvaluation","rightEvaluation","comp","gradientSimultaneousPerturbation","Error","HelloWorld","Object","assign","target","__target__","TestBed","spec","minimumValue","maximumValue","copy","optimumValue","resolution","testbeds","Ackley","PI","vs","term1","term2","cos","crossInTray","sin","Griewank","prod","Levy","w","w1","wd","Michalewicz","m","perm0","beta","sum2","sum1","Rastrigin","Rosenbrock","Schwefel","sphere","sumOptimization","ZDT1","f1","g","tail","ZDT2","ZDT3","NQueensPuzzle","N","__rowRange__","rows","row","KnapsackProblem","itemA","cost","worth","itemB","itemC","itemD","itemE","__elementItems__","keys","amount","toObject","forEachApply","item","limit","AssociationRuleLearning","antecedent","consequent","keysComply","record","it","isEmpty","antecedentComplies","rule","consequentComplies","measures","totalCount","antecedentCount","consequentCount","ruleCount","dataset","antecedentSupport","consequentSupport","ruleSupport","confidence","lift","conviction","leverage","__measures__","type"],"mappings":"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","file":"inveniemus.min.js","sourcesContent":["/** Package wrapper and layout.\n*/\nfunction __init__(base, Sermat){ \"use strict\";\n// Import synonyms. ////////////////////////////////////////////////////////////////////////////////\n\tvar declare = base.declare,\n\t\titerable = base.iterable,\n\t\tinitialize = base.initialize,\n\t\traise = base.raise,\n\t\traiseIf = base.raiseIf,\n\t\tEvents = base.Events,\n\t\tFuture = base.Future,\n\t\tIterable = base.Iterable,\n\t\tLogger = base.Logger,\n\t\tRandomness = base.Randomness,\n\t\tStatistics = base.Statistics;\n\n// Library layout. /////////////////////////////////////////////////////////////////////////////////\n\tvar exports = {\n\t\t\t__package__: 'inveniemus',\n\t\t\t__name__: 'inveniemus',\n\t\t\t__init__: __init__,\n\t\t\t__dependencies__: [base],\n\t\t\t__SERMAT__: { include: [] }\n\t\t},\n\t/** `metaheuristics` is a bundle of available metaheuristics.\n\t*/\n\t\tmetaheuristics = exports.metaheuristics = {},\n\t/** `problems` is a bundle of classic and reference problems.\n\t*/\n\t\tproblems = exports.problems = {},\n\t/** `utilities` is the namespace for miscelaneous utility functions and definitions.\n\t*/\n\t\tutilities = exports.utilities = {}\n\t;\n","/** # Utilities\n\nMiscelaneous utility functions and definitions.\n*/\n\nvar clamp = utilities.clamp = function clamp(value, min, max) {\n\treturn Math.max(min, Math.min(max, value));\n};\n\n/** A good string representation for element values for logging and debugging can be very useful.\nThe Han encoding uses characters for eastern asian scripts in the Unicode standard. The CJK\n(Chinese-Japanese-Korean) unification provides a continuous block of 21035 printable characters,\nstarting at 0x4DC0 (Y-Ching hexagrams). The Hangul syllables provide another continuous block of\n11172 printable characters.\n\nThe encoding is meant to be human-readable. These characters are also supported by most fonts used\nin shells and browsers. Picking up the actual values is difficult, but it is easy to tell if\nelements (or particular values) are equal or not. Also it is possible to quickly copy a paste the\ntext representation.\n\nThis encoding is not meant to be efficient. Using UTF-8 all characters beyond 0x7FF require 3 bytes.\nIf storage or bandwidth are of concern, base64 would probably work better.\n*/\nutilities.emblemHan = function emblemHan(element) {\n\tvar evaluation = !element.evaluation ? '?' : element.evaluation.map(function (e) {\n\t\t\treturn isNaN(e) ? '?' : Math.round(+e * 1e6) / 1e6;\n\t\t}).join(',');\n\treturn '[Element '+ evaluation +' '+ encodeHan(element.values()) +']';\n};\n\n(function () {\n\tvar\tBEGIN_CJK = 0x4DC0,\n\t\tEND_CJK = 0x9FD0,\n\t \tCOUNT_CJK = END_CJK - BEGIN_CJK + 1,\n\t\tBEGIN_HANGUL = 0xAC00,\n\t\tEND_HANGUL = 0xD7A3,\n\t\tCOUNT_HANGUL = END_HANGUL - BEGIN_HANGUL + 1;\n\tutilities.encodeHan = function encodeHan(values) {\n\t\treturn values.map(function (v) {\n\t\t\tv = v |0;\n\t\t\traiseIf(v > COUNT_CJK,\n\t\t\t\t\"Values like \", v, \" > \", COUNT_CJK, \" cannot be encoded!\");\n\t\t\traiseIf(v < -COUNT_HANGUL,\n\t\t\t\t\"Values like \", v, \" < \", -COUNT_HANGUL, \" cannot be encoded!\");\n\t\t\treturn String.fromCharCode(v + (v >= 0 ? BEGIN_CJK : END_HANGUL + 1));\n\t\t}).join('');\n\t};\n\tutilities.decodeHan = function decodeHan(string) {\n\t\treturn string.split('').map(function (chr) {\n\t\t\tvar v = chr.charCodeAt(0);\n\t\t\tif (v >= BEGIN_CJK && v <= END_CJK) {\n\t\t\t\treturn v - BEGIN_CJK;\n\t\t\t} else if (v >= BEGIN_HANGUL && v <= END_HANGUL) {\n\t\t\t\treturn v - END_HANGUL - 1;\n\t\t\t} else {\n\t\t\t\traise(\"Cannot decode character '\"+ chr +\"'!\");\n\t\t\t}\n\t\t});\n\t};\n})();\n\nvar encodeHan = utilities.encodeHan;\n","/**\t# Element\n\nElement is the term used in Inveniemus for representations of\n[candidate solutions](http://en.wikipedia.org/wiki/Feasible_region) in a search or optimization\n[problem](Problem.js.html). Implementations may declare their own subclass of `Element` to represent\ntheir candidate solutions.\n*/\nvar Element = exports.Element = declare({\n\t/** All elements are defined by a `problem`, an array of numbers (i.e. the element's `values`,\n\trandom numbers by default) and an `evaluation` (`NaN` by default). The element's values are\n\tcoerced to be in the range provided by the problem's element model.\n\n\tThe `values` store all data about the candidate solution this element represents. This may\n\tappear to abstract and stark, but it helps to separate the problem definition from the search\n\tor optimization strategy.\n\n\tThe element's `evaluation` is a numerical assessment of the represented candidate solution.\n\tUsually is a measure of how well the problem is solved, or how close the element is to a real\n\tsolution. It guides almost all of the metaheuristics.\n\t*/\n\tconstructor: function Element(values, evaluation) {\n\t\tthis.__values__ = !values ? this.randomValues() : this.checkValues(values, false);\n\t\tthis.evaluation = evaluation;\n\t},\n\n\t'property evaluation': {\n\t\tget: function getEvaluation() {\n\t\t\treturn this.__evaluation__;\n\t\t},\n\t\tset: function setEvaluation(e) {\n\t\t\tif (Array.isArray(e) || !isNaN(e) && e !== null) {\n\t\t\t\tthis.__evaluation__ = (Array.isArray(e) ? e : [e]).map(function (v) {\n\t\t\t\t\treturn +v;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.__evaluation__ = null;\n\t\t\t}\n\t\t}\n\t},\n\n\t/** The `ArrayType` is the internal representation of the elements' `values`. It is\n\t`Uint32Array` by default.\n\t*/\n\tArrayType: Uint32Array,\n\n\t/** It is usually more convenient to have the `values` in an instance of `Array` than an\n\tinstance of a typed array.\n\t*/\n\tvalues: function values() {\n\t\treturn Array.prototype.slice.call(this.__values__);\n\t},\n\n\t/** The default element `model` defines 10 dimensions with 2^32 values. Please override.\n\t*/\n\tmodel: Iterable.repeat({ n: 128 }, 10).toArray(),\n\n\t/** Random values are integers within the range defined by the element's model.\n\t*/\n\trandomValue: function randomValue(i) {\n\t\treturn this.problem.random.randomInt(0, this.model[i].n) |0;\n\t},\n\n\trandomValues: function randomValues() {\n\t\tvar random = this.problem.random;\n\t\treturn new this.ArrayType(this.model.map(function (model) {\n\t\t\treturn random.randomInt(0, model.n) |0;\n\t\t}));\n\t},\n\n\t/** Checks if all given `values` are within the range defined by this element's model. If\n\t`coerce` is false any invalid values raises an error. Else values are coerced to fit the\n\telement's model.\n\t*/\n\tcheckValues: function checkValues(values, coerce) {\n\t\treturn new this.ArrayType(this.model.map(function (model, i) {\n\t\t\tvar v = values[i],\n\t\t\t\tn = model.n;\n\t\t\tif (isNaN(v)) {\n\t\t\t\traiseIf(!coerce, \"Value #\", i, \" (\", v, \") is NaN!\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (v < 0 || v >= n) {\n\t\t\t\traiseIf(!coerce, \"Value #\", i, \" (\", v, \") is out of range [0,\", n-1, \"]!\");\n\t\t\t\treturn v < 0 ? 0 : n - 1;\n\t\t\t}\n\t\t\treturn v;\n\t\t}));\n\t},\n\n\t/** Whether this element is an actual solution or not is decided by `suffices()`, which is\n\tdelegated to `Problem.sufficientElement` by default.\n\t*/\n\tsuffices: function suffices() {\n\t\treturn this.problem.sufficientElement(this);\n\t},\n\n\t/** The `emblem` of an element is a string that represents it and can be displayed to the user.\n\tBy default returns a custom string representation.\n\t*/\n\temblem: function emblem() {\n\t\treturn '[Element '+ this.evaluation +' '+ this.values().join(',') +']';\n\t},\n\n\t// ## Evaluations ##############################################################################\n\n\t/** The element's `evaluation` is calculated by `evaluate()`, which assigns and returns this\n\tarray of numbers. It may return a promise if the evaluation has to be done asynchronously. This\n\tcan be interpreted as the solution's cost in a search problem or the target function of an\n\toptimization problem.\n\t*/\n\tevaluate: function evaluate() {\n\t\tvar elem = this;\n\t\treturn Future.then(this.problem.evaluation(this), function (e) {\n\t\t\telem.evaluation = e;\n\t\t\traiseIf(elem.evaluation === null, 'The evaluation of ', elem, ' is null!');\n\t\t\treturn elem.evaluation;\n\t\t});\n\t},\n\n\t/** The [Hamming distance](http://en.wikipedia.org/wiki/Hamming_distance) between two arrays is\n\tthe number of positions at which corresponding components are different. Arrays are assumed to\n\tbe of the same length. If they are not, only the common parts are considered.\n\t*/\n\thammingDistance: function hammingDistance(array1, array2) {\n\t\tvar count = 0;\n\t\tfor (var i = 0, len = Math.min(array1.length, array2.length); i < len; i++) {\n\t\t\tif (array1[i] !== array2[i]) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t},\n\n\t/** The [Manhattan distance](http://en.wikipedia.org/wiki/Manhattan_distance) between two\n\tarrays is the sum of the absolute differences of corresponding positions.\n\t*/\n\tmanhattanDistance: function manhattanDistance(array1, array2) {\n\t\tvar sum = 0;\n\t\tfor (var i = 0, len = Math.min(array1.length, array2.length); i < len; i++) {\n\t\t\tsum += Math.abs(array1[i] - array2[i]);\n\t\t}\n\t\treturn sum;\n\t},\n\n\t/** The [euclidean distance](http://en.wikipedia.org/wiki/Euclidean_distance) between two\n\tarrays is another option for evaluation.\n\t*/\n\teuclideanDistance: function euclideanDistance(array1, array2) {\n\t\tvar sum = 0;\n\t\tfor (var i = 0, len = Math.min(array1.length, array2.length); i < len; i++) {\n\t\t\tsum += Math.pow(array1[i] - array2[i], 2);\n\t\t}\n\t\treturn Math.sqrt(sum);\n\t},\n\n\t/** Another common evaluation is the [root mean squared error](http://en.wikipedia.org/wiki/Root_mean_squared_error).\n\tThe method `rootMeanSquaredError` takes a function `f` (usually a mapping of this element) and\n\tsome `data`. This `data` must be an iterable of arrays, in which the first element is the\n\texpected result and the rest are the arguments for the function.\n\t*/\n\trootMeanSquaredError: function rootMeanSquaredError(f, data) {\n\t\tvar length = 0,\n\t\t\terror = iterable(data).map(function (datum) {\n\t\t\t\tlength++;\n\t\t\t\treturn Math.pow(datum[0] - f.apply(this, datum.slice(1)), 2);\n\t\t\t}).sum();\n\t\treturn length === 0 ? 0 : Math.sqrt(error / length);\n\t},\n\n\t/** Finding out if this element is better than other uses the problem's `compare` method.\n\t*/\n\tisBetterThan: function isBetterThan(other) {\n\t\treturn this.problem.compare(this, other) > 0;\n\t},\n\n\t// ## Expansions ###############################################################################\n\n\t/** An element's `neighbourhood` is a set of new elements, with values belonging to the n\n\tdimensional ball around this element's values with the given `radius` (1 by default).\n\t*/\n\tneighbourhood: function neighbourhood(radius) {\n\t\tvar neighbours = [],\n\t\t\tmodel = this.model,\n\t\t\tvalues = this.__values__,\n\t\t\td = Math.abs(Array.isArray(radius) ? radius[i] : radius),\n\t\t\tn, value;\n\t\tif (isNaN(d)) {\n\t\t\td = 1;\n\t\t}\n\t\tfor (var i = 0, len = values.length; i < len; i++) {\n\t\t\tvalue = values[i];\n\t\t\tn = model[i].n;\n\t\t\tif (value > 0) {\n\t\t\t\tneighbours.push(this.modification(i, Math.max(0, value - d)));\n\t\t\t}\n\t\t\tif (value < n - 1) {\n\t\t\t\tneighbours.push(this.modification(i, Math.min(n - 1, value + d)));\n\t\t\t}\n\t\t}\n\t\treturn neighbours;\n\t},\n\n\t/** The method `modification(index, value, ...)` returns a new and unevaluated copy of this\n\telement, with its values modified as specified. Values are always coerced to the element's\n\tmodel.\n\t*/\n\tmodification: function modification() {\n\t\tvar newValues = this.__values__.slice(),\n\t\t\tpos;\n\t\tfor (var i = 0; i < arguments.length; i += 2) {\n\t\t\tpos = arguments[i] |0;\n\t\t\tnewValues[pos] = clamp(arguments[i + 1], 0, this.model[i].n - 1);\n\t\t}\n\t\treturn new this.constructor(newValues);\n\t},\n\n\t// ## Mappings #################################################################################\n\n\t/** Gives an alternate representation of this element. See `Problem.mapping()`.\n\t*/\n\tmapping: function mapping() {\n\t\treturn this.problem.mapping(this);\n\t},\n\n\t/** A range mapping builds an array of equal length of this element's `values`. Each value is\n\ttranslated from the element model's range to the given range.\n\t*/\n\trangeMapping: function rangeMapping() {\n\t\tvar args = arguments,\n\t\t\tmodel = this.model,\n\t\t\tlastRange = args[args.length - 1];\n\t\traiseIf(args.length < 1, \"Element.rangeMapping() expects at least one argument!\");\n\t\treturn Array.prototype.map.call(this.__values__, function (v, i) {\n\t\t\tvar n = model[i].n,\n\t\t\t\trangeTo = args.length > i ? args[i] : lastRange;\n\t\t\tv = v / n * (rangeTo[1] - rangeTo[0]) + rangeTo[0];\n\t\t\treturn clamp(v, rangeTo[0], rangeTo[1]);\n\t\t});\n\t},\n\n\t/** The `normalizedValues` of an element is a mapping to the range [0,1].\n\t*/\n\tnormalizedValues: function normalizedValues() {\n\t\treturn this.rangeMapping([0, 1]);\n\t},\n\n\t/** An array mapping builds an array of equal length of this element's `values`. Each value is\n\tused to index the corresponding items argument. If there are less arguments than the element's\n\t`length`, the last one is used for the rest of the values.\n\t*/\n\tarrayMapping: function arrayMapping() {\n\t\tvar args = arguments,\n\t\t\tlastItems = args[args.length - 1],\n\t\t\tmodel = this.model;\n\t\traiseIf(args.length < 1, \"Element.arrayMapping() expects at least one argument!\");\n\t\treturn Array.prototype.map.call(this.__values__, function (v, i) {\n\t\t\tvar items = args.length > i ? args[i] : lastItems,\n\t\t\t\tn = model[i].n,\n\t\t\t\tindex = Math.floor(v / n * items.length);\n\t\t\treturn items[index];\n\t\t});\n\t},\n\n\t/** A set mapping builds an array of equal length of this element's `values`. Each value is\n\tused to select one item. Items are not selected more than once.\n\t*/\n\tsetMapping: function setMapping(items, full) {\n\t\traiseIf(!Array.isArray(items), \"Element.setMapping() expects an array argument!\");\n\t\titems = items.slice(); // Shallow copy.\n\t\tvar result = this.normalizedValues().map(function (v, i) {\n\t\t\t\traiseIf(items.length < 1, \"Element.setMapping(): insufficient elements!\");\n\t\t\t\tvar index = clamp(Math.floor(v * items.length), 0, items.length - 1);\n\t\t\t\treturn items.splice(index, 1)[0];\n\t\t\t});\n\t\tif (full) {\n\t\t\traiseIf(items.length != 1, \"Element.setMapping(): wrong amount of elements!\");\n\t\t\tresult.push(items[0]);\n\t\t}\n\t\treturn result;\n\t},\n\n\t// ## Other utilities ##########################################################################\n\n\t/** A `clone` is a copy of this element.\n\t*/\n\tclone: function clone() {\n\t\treturn new this.constructor(this.__values__, this.evaluation);\n\t},\n\n\t/** Two elements can be compared with `equals(other)`. It checks if the other element has the\n\tsame values and constructor than this one.\n\t*/\n\tequals: function equals(other) {\n\t\tif (this.constructor === other.constructor &&\n\t\t\t\tthis.__values__.length === other.__values__.length) {\n\t\t\tfor (var i = 0, len = this.__values__.length; i < len; i++) {\n\t\t\t\tif (this.__values__[i] !== other.__values__[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t/** The default string representation of an Element is its Sermat serialization.\n\t*/\n\ttoString: function toString() {\n\t\treturn Sermat.ser(this);\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Element',\n\t\tserializer: function serialize_Element(obj) {\n\t\t\treturn [obj.problem, obj.values(), obj.evaluation];\n\t\t},\n\t\tmaterializer: function materialize_Element(obj, args) {\n\t\t\treturn !args ? null : new args[0].Element(args[1], args[2]);\n\t\t}\n\t}\n}); // declare Element.\n","/**\t# Problem\n\nThe Problem type represents a search or optimization problem in Inveniemus.\n*/\nvar Problem = exports.Problem = declare({\n\t/** The problem constructor takes many parameters:\n\t*/\n\tconstructor: function Problem(params) {\n\t\tparams = params || {};\n\t\tinitialize(this, params)\n\t\t\t/** + The `title` and `description` are meant to be displayed to the user in UIs and\n\t\t\tlogs.\n\t\t\t*/\n\t\t\t.string('title', { ignore: true, coerce: true })\n\t\t\t.string('description', { ignore: true, coerce: true })\n\t\t\t/** + A `random` number generator, required by many operations. By default\n\t\t\t`base.Randomness.DEFAULT` is used, which uses the standard `Math.random()`\n\t\t\tfunction.\n\t\t\t*/\n\t\t\t.object('random', { ignore: true })\n\t\t\t/** + The `objetives` define the mode of the optimization. This is an array of at\n\t\t\tleast one number. More than one implies a multi-objetive optimization. Minimization\n\t\t\thas `-Infinity` as an objective, hence maximization has `+Infinity`. A number makes\n\t\t\tthe optimization approximate it.\n\t\t\t*/\n\t\t\t.array('objectives', { ignore: true })\n\t\t\t/** + The `elementModel` defines the elements' dimensions, each with a number `n` of\n\t\t\tpossible values (from 0 to `n`).\n\t\t\t*/\n\t\t\t.array('elementModel', { ignore: true })\n\t\t\t/** + The `Element` parameter can be used to specify a particular element type. The\n\t\t\tactual element class used is derived from this, or the base `Element` class if none\n\t\t\tis given.\n\t\t\t*/\n\t\t\t.func('Element', { ignore: true })\n\t\t;\n\t\t/** + `objective` is a shortcut for `objectives` when there is only one.\n\t\t*/\n\t\tif (!isNaN(params.objective)) {\n\t\t\tthis.objectives = [params.objective];\n\t\t}\n\t\t/** Every problem defines a type for its `Element`s.\n\t\t*/\n\t\tthis.Element = declare(this.Element || Element, {\n\t\t\tproblem: this\n\t\t});\n\t\tif (params.elementModel) {\n\t\t\tthis.Element.prototype.model = params.elementModel;\n\t\t}\n\t},\n\n\t/** The defaults for some of the parameters are placed in the `Problem`'s prototype.\n\t*/\n\ttitle: \"Problem.title?\",\n\tdescription: \"Problem.description?\",\n\trandom: Randomness.DEFAULT,\n\tobjectives: [-Infinity],\n\n\t/** The problem's elements must be evaluated somehow. This can be interpreted as the solution's\n\tcost in a search problem or the target function of an optimization problem. The default\n\tbehaviour is adding up this element's values, useful only for testing. It can return a future\n\tif the evaluation has to be done asynchronously.\n\t*/\n\tevaluation: function evaluation(element) {\n\t\treturn iterable(element.values()).sum();\n\t},\n\n\t/** The `evaluate` method is used to assign an evaluation to all the given `elements`. By\n\tdefault it iterates over all elements and gets their evaluation using the `evaluation` method.\n\tIf `reevaluate` is false (the default), already evaluated elements are ignored. This method may\n\tbe overriden to make a relative evaluation scheme (e.g. in coevolution).\n\t*/\n\tevaluate: function evaluate(elements, reevaluate) {\n\t\tvar async = false;\n\t\telements = iterable(elements).filter(\n\t\t\tfunction (element) {\n\t\t\t\treturn reevaluate || element.evaluation === null;\n\t\t\t},\n\t\t\tfunction (element) { // ... evaluate them.\n\t\t\t\tvar result = element.evaluate();\n\t\t\t\tasync = async || Future.__isFuture__(result);\n\t\t\t\treturn result;\n\t\t\t}).toArray();\n\t\treturn async ? Future.all(elements) : elements;\n\t},\n\n\t/** Usually a numbers array is just too abstract to handle, and\tanother representation of the\n\tcandidate solution must be build. For this `mapping()` must be overridden to returns an\n\talternate representation of an element that may be fitter for evaluation or showing it to the\n\tuser. By default it just returns the `element`s values normalized.\n\t*/\n\tmapping: function mapping(element) {\n\t\treturn element.normalizedValues();\n\t},\n\n\t/** An element is `sufficient` when it can be considered a solution of a search or a good\n\tenough solution of an optimization. By default it returns false.\n\t*/\n\tsufficientElement: function sufficientElement(element) {\n\t\treturn false;\n\t},\n\n\t/** When a set of elements is sufficient, the search/optimization may end. The method\n\t`suffices(elements)` returns `true` if inside the elements array there are enough actual\n\tsolutions to this problem. It holds the implementation of the goal test in search problems. By\n\tdefault calls the `suffice` method of the first element (assumed to be the best one).\n\t*/\n\tsufficientElements: function sufficientElements(elements) {\n\t\treturn this.sufficientElement(elements[0]);\n\t},\n\n\t// ## Optimization modes #######################################################################\n\n\t/** How elements are compared with each other in the problem determines which kind of\n\toptimization is performed. The `compare` method implements the comparison between two elements.\n\tIt returns a positive number if `element2` is better than `element1`, a negative number if\n\t`element2` is worse then `element1`, or zero otherwise. Better and worse may mean less or\n\tgreater evaluation (`minimization`), viceversa (`maximization`) or another criteria altogether.\n\t*/\n\tcompare: function compare(element1, element2) {\n\t\tif (this.objectives.length === 1) {\n\t\t\treturn this.singleObjectiveComparison(this.objectives[0],\n\t\t\t\telement1.evaluation[0], element2.evaluation[0]);\n\t\t} else {\n\t\t\treturn this.paretoComparison(this.objectives,\n\t\t\t\telement1.evaluation, element2.evaluation);\n\t\t}\n\t},\n\n\t/** A single objective optimization has three modes, given by the `objective` parameter:\n\t*/\n\tsingleObjectiveComparison: function singleObjectiveComparison(objective, value1, value2) {\n\t\tvar d;\n\t\tswitch (objective) {\n\t\t\t/** + `-Infinity` means minimization. */\n\t\t\tcase -Infinity: {\n\t\t\t\td = value2 - value1;\n\t\t\t\treturn isNaN(d) ? Infinity : d;\n\t\t\t}\n\t\t\t/** + `+Infinity` means maximization. */\n\t\t\tcase +Infinity: {\n\t\t\t\td = value1 - value2;\n\t\t\t\treturn isNaN(d) ? -Infinity : d;\n\t\t\t}\n\t\t\t/** + An actual number means approximation to said value. */\n\t\t\tdefault: {\n\t\t\t\td = Math.abs(value2 - objective) - Math.abs(value1 - objective);\n\t\t\t\treturn isNaN(d) ? Infinity : d;\n\t\t\t}\n\t\t}\n\t},\n\n\t/** The [Pareto efficiency](https://en.wikipedia.org/wiki/Pareto_efficiency) is frequently used\n\tin multiobjective optimizations, yet it is not a complete order. The `paretoComparison` method\n\ttakes an array of `objectives`, and two arrays of numbers to be compared. The result is an array\n\tof comparisons (-1, 0 or 1) with a `domination` property. If `domination` is:\n\n\t+ `< 0`: `element2` dominates `element1`.\n\n\t+ `> 0`: `element1` dominates `element2`.\n\n\t+ `= 0`: both elements are equally evaluated.\n\n\t+ `NaN`: elements could not be compared (i.e. their evaluations are different, but they do not\n\t\tdominate each other).\n\t*/\n\tparetoComparison: function paretoComparison(objectives, values1, values2) {\n\t\tvar worse = 0, better = 0,\n\t\t\tproblem = this,\n\t\t\tresult;\n\t\traiseIf(objectives.length !== values1.length, \"Expected \", objectives.length,\n\t\t\t\" evaluations, but got \", values1.length, \"!\");\n\t\traiseIf(objectives.length !== values2.length, \"Expected \", objectives.length,\n\t\t\t\" evaluations, but got \", values2.length, \"!\");\n\t\tresult = Iterable.zip(objectives, values1, values2).mapApply(function (objective, value1, value2) {\n\t\t\tvar r = problem.singleObjectiveComparison(objective, value1, value2);\n\t\t\tif (r < 0) {\n\t\t\t\tworse++;\n\t\t\t} else if (r > 0) {\n\t\t\t\tbetter++;\n\t\t\t}\n\t\t\treturn r;\n\t\t}).toArray();\n\t\tresult.domination = worse === 0 ? better : better === 0 ? -worse : NaN;\n\t\treturn result;\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Returns a reconstruction of the parameters used in the construction of this instance.\n\t*/\n\t__params__: function __params__() { //FIXME\n\t\tvar params = {},\n\t\t\tself = this,\n\t\t\tids = arguments.length > 0 ? Array.prototype.slice.call(arguments) :\n\t\t\t\t['title', 'description', 'random', 'objectives', 'elementModel'];\n\t\tids.forEach(function (id) {\n\t\t\tif (typeof self[id] !== 'undefined') {\n\t\t\t\tparams[id] = self[id];\n\t\t\t}\n\t\t});\n\t\treturn params;\n\t},\n\n\t/** The default string representation of a Problem is its Sermat serialization.\n\t*/\n\ttoString: function toString() {\n\t\treturn Sermat.ser(this);\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Problem',\n\t\tserializer: function serialize_Problem(obj) {\n\t\t\treturn [obj.__params__()];\n\t\t}\n\t}\n}); // declare Problem.\n","/**\t# Metaheuristic\n\nA [Metaheuristic](http://en.wikipedia.org/wiki/Metaheuristic) is an optimization algorithm (which\ncan also be used for searching). This is the base class of all metaheuristic algorithms, and hence\nof all metaheuristic runs.\n*/\nvar Metaheuristic = exports.Metaheuristic = declare({\n\t/** Each metaheuristic has its own `logger`, to track its process.\n\t*/\n\tlogger: new Logger('inveniemus', Logger.ROOT, 'INFO'),\n\n\t/** The constructor takes a `params` object with the metaheuristic parameters. Although the\n\tdifferent algorithms have particular parameters of their own, some apply to all.\n\t*/\n\tconstructor: function Metaheuristic(params) {\n\t\tinitialize(this, params)\n\t\t/** First, the definition of the `problem` this metaheuristic is meant to solve.\n\t\t*/\n\t\t\t.object('problem', { defaultValue: null })\n\t\t/** The optimization's `size` is the amount of candidate solutions the metaheuristic treats\n\t\tat each step. By default it is 100.\n\t\t*/\n\t\t\t.number('size', { defaultValue: 100, coerce: true })\n\t\t/** The `state` is the array that holds the elements this metaheuristic handles at each step.\n\t\t*/\n\t\t\t.array('state', { defaultValue: [] })\n\t\t/** All optimizations perform a certain number of iterations or `steps` (100 by default).\n\t\t*/\n\t\t\t.number('steps', { defaultValue: 100, coerce: true })\n\t\t/** The property `step` indicates the current iteration of this optimization, or a negative\n\t\tnumber if it has not started yet.\n\t\t*/\n\t\t\t.integer('step', { defaultValue: -1, coerce: true })\n\t\t/** Most metaheuristic are stochastic processes, hence the need for a pseudo-random number\n\t\tgenerator. By default `base.Randomness.DEFAULT` is used, yet it is strongly advised to\n\t\tprovide one.\n\t\t*/\n\t\t\t.object('random', { defaultValue: Randomness.DEFAULT })\n\t\t/** Metaheuristic's runs usually gather `statistics` about the process.\n\t\t*/\n\t\t\t.object('statistics', { defaultValue: new Statistics() })\n\t\t\t.object('logger', { ignore: true });\n\t\tthis.events = new Events({\n\t\t\tevents: [\"initiated\", \"updated\", \"expanded\", \"evaluated\", \"sieved\", \"advanced\", \"analyzed\", \"finished\"]\n\t\t});\n\t},\n\n\t__log__: function __log__(level) {\n\t\tif (this.logger) {\n\t\t\tthis.logger[level].apply(this.logger, arguments);\n\t\t}\n\t},\n\n\t// ## Basic workflow ###########################################################################\n\n\t/**\t`initiate(size=this.size)` builds and initiates this metaheuristic state with size new\n\tcursors. The elements are build using the `initial()` function.\n\t*/\n\tinitiate: function initiate(size) {\n\t\tsize = isNaN(size) ? this.size : +size || 0;\n\t\tthis.state = new Array(size);\n\t\tfor (var i = 0; i < size; i++) {\n\t\t\tthis.state[i] = new this.problem.Element(); // Element with random values.\n\t\t}\n\t\tthis.onInitiate();\n\t},\n\n\t/** `update()` updates this metaheuristic's state. It assumes the state has been initialized.\n\tThe process may be asynchronous, so it returns a future. The default implementation first\n\texpands the state by calling `expand()`, then evaluates the added elements by calling\n\t`evaluate()`, and finally removes the worst elements with `sieve()`.\n\t*/\n\tupdate: function update() {\n\t\tvar mh = this;\n\t\tthis.expand();\n\t\treturn Future.then(this.evaluate(), function () {\n\t\t\tmh.sieve();\n\t\t\tmh.onUpdate();\n\t\t\treturn mh;\n\t\t});\n\t},\n\n\t/** `expand(expansion=[])` adds to this metaheuristic's state the given expansion. If none is\n\tgiven, `expansion()` is called to get new expansion.\n\t*/\n\texpand: function expand(expansion) {\n\t\texpansion = expansion || this.expansion();\n\t\tif (expansion.length < 1) {\n\t\t\tthis.__log__('warn', \"Expansion is empty\");\n\t\t} else {\n\t\t\tthis.state = this.state.concat(expansion);\n\t\t}\n\t\tthis.onExpand();\n\t},\n\n\t/** `expansion(size)` returns an array of new elements to add to the current state. The default\n\timplementation generates new random elements.\n\t*/\n\texpansion: function expansion(size) {\n\t\tvar expansionRate = isNaN(this.expansionRate) ? 1 : +this.expansionRate;\n\t\tsize = isNaN(size) ? Math.floor(expansionRate * this.size) : +size;\n\t\tvar elems = new Array(size), i;\n\t\tfor (i = 0; i < size; i++){\n\t\t\telems[i] = new this.problem.Element();\n\t\t}\n\t\treturn elems;\n\t},\n\n\t/** `evaluate(elements)` evaluates all the elements in `state` with no evaluation, using its\n\tevaluation method. After that sorts the state with the `compare` method of the problem. May\n\treturn a future, if any evaluation is asynchronous.\n\t*/\n\tevaluate: function evaluate(elements) {\n\t\tvar mh = this,\n\t\t\tevalTime = this.statistics && this.statistics.stat({key:'evaluation_time'});\n\t\tif (evalTime) evalTime.startTime();\n\t\telements = elements || this.state;\n\t\treturn Future.then(this.problem.evaluate(elements), function (results) {\n\t\t\telements = mh.sort(elements);\n\t\t\tif (evalTime) evalTime.addTime();\n\t\t\tmh.onEvaluate(results);\n\t\t\treturn elements;\n\t\t});\n\t},\n\n\t/** `sort(elements)` TODO\n\t*/\n\tsort: function sort(elements) {\n\t\telements = elements || this.state;\n\t\tif (this.problem.objectives.length > 1) { // Multi-objective optimization.\n\t\t\telements = this.multiObjectiveSort(elements);\n\t\t} else { // Single-objective optimization.\n\t\t\telements.sort(this.problem.compare.bind(this.problem));\n\t\t\telements.reverse();\n\t\t}\n\t\treturn elements;\n\t},\n\n\t/** `sieve(size=this.size)` cuts the current state down to the given size (or this.size by\n\tdefault). This is usually used after expanding and evaluating the state.\n\t*/\n\tsieve: function sieve(size) {\n\t\tsize = isNaN(size) ? this.size : Math.floor(size);\n\t\tif (this.state.length > size) {\n\t\t\tthis.state = this.state.slice(0, this.size);\n\t\t}\n\t\tthis.onSieve();\n\t},\n\n\t/** `finished()` termination criteria for this metaheuristic. By default it checks if the number\n\tof passed iterations is not greater than `steps`.\n\t*/\n\tfinished: function finished() {\n\t\treturn this.step >= this.steps || this.problem.sufficientElements(this.state);\n\t},\n\n\t/** `analyze()` updates the process' statistics.\n\t*/\n\tanalyze: function analyze(statistics) {\n\t\tstatistics = statistics || this.statistics;\n\t\tvar step = this.step;\n\t\tif (statistics) {\n\t\t\tif (this.state[0].evaluation.length === 1) { // Single-objective optimization.\n\t\t\t\tvar stat_evaluation = statistics.stat({ key:'evaluation', step: step });\n\t\t\t\tthis.state.forEach(function (element) {\n\t\t\t\t\tif (element.evaluation) {\n\t\t\t\t\t\tstat_evaluation.add(element.evaluation[0], element);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else { // Multi-objective optimization.\n\t\t\t\tvar stats_evaluation = this.state[0].evaluation.map(function (_, i) {\n\t\t\t\t\t\treturn statistics.stat({ key:'evaluation', index: i, step: step });\n\t\t\t\t\t}),\n\t\t\t\t\tstat_dominators = statistics.stat({ key:'dominators', step: step }),\n\t\t\t\t\tstat_dominated = statistics.stat({ key:'dominated', step: step });\n\t\t\t\tthis.state.forEach(function (element) {\n\t\t\t\t\telement.evaluation.forEach(function (v, i) {\n\t\t\t\t\t\tstats_evaluation[i].add(v, element);\n\t\t\t\t\t});\n\t\t\t\t\tstat_dominators.add(element.pareto.dominators.length, element);\n\t\t\t\t\tstat_dominated.add(element.pareto.dominated.length, element);\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.onAnalyze();\n\t\t}\n\t\treturn statistics;\n\t},\n\n\t/** `advance()` performs one step of the optimization. If the process has not been initialized,\n\tit does so. Returns a future if any step is asynchronous.\n\t*/\n\tadvance: function advance() {\n\t\tvar mh = this,\n\t\t\tstepTime = this.statistics && this.statistics.stat({key: 'step_time'}),\n\t\t\tresult;\n\t\tif (isNaN(this.step) || +this.step < 0) {\n\t\t\tthis.reset();\n\t\t\tif (stepTime) stepTime.startTime();\n\t\t\tthis.initiate();\n\t\t\tresult = this.evaluate();\n\t\t} else {\n\t\t\tif (stepTime) stepTime.startTime();\n\t\t\tresult = this.update();\n\t\t}\n\t\treturn Future.then(result, function () {\n\t\t\tmh.step = isNaN(mh.step) || +mh.step < 0 ? 0 : +mh.step + 1;\n\t\t\tmh.analyze(); // Calculate the state's stats after updating it.\n\t\t\tif (stepTime) stepTime.addTime();\n\t\t\tmh.onAdvance();\n\t\t\treturn mh;\n\t\t});\n\t},\n\n\t/** `run()` returns a future that is resolved when the whole search process is finished. The\n\tvalue is the best cursor after the last step. It always returns a future.\n\t*/\n\trun: function run() {\n\t\tvar mh = this,\n\t\t\tadvance = this.advance.bind(this),\n\t\t\tcontinues = function continues() {\n\t\t\t\treturn !mh.finished();\n\t\t\t};\n\t\treturn Future.doWhile(advance, continues).then(function () {\n\t\t\tmh.onFinish();\n\t\t\treturn mh.state[0]; // Return the best cursor.\n\t\t});\n\t},\n\n\t/** `reset()` reset the process to start over again. Basically cleans the statistics and sets\n\tthe current `step` to -1.\n\t*/\n\treset: function reset() {\n\t\tthis.step = -1;\n\t\tif (this.statistics) this.statistics.reset();\n\t},\n\n\t// ## State control ############################################################################\n\n\t/** The `nub` method eliminates repeated elements inside the state. Use responsibly, since this\n\tis an expensive operation. Returns the size of the resulting state.\n\t*/\n\tnub: function nub(precision) {\n\t\tprecision = +precision || 0;\n\t\tthis.state = iterable(this.state).nub(function (e1, e2) {\n\t\t\tvar values1 = e1.__values__,\n\t\t\t\tvalues2 = e2.__values__,\n\t\t\t\tlen = values1.length;\n\t\t\tif (len !== values2.length) {\n\t\t\t\treturn false;\n\t\t\t} else for (var i = 0; i < len; ++i) {\n\t\t\t\tif (Math.abs(values1[i] - values2[i]) > precision) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}).toArray();\n\t\treturn this.state.length;\n\t},\n\n\t// ## Events ###################################################################################\n\n\t/** For better customization the `events` handler emits the following events:\n\n\t+ `initiated` when the state has been initialized.\n\t*/\n\tonInitiate: function onInitiate() {\n\t\tthis.events.emit('initiated', this);\n\t\tthis.__log__('debug', 'State has been initiated. Nos coepimus.');\n\t},\n\n\t/** + `updated` when the state has been expanded, evaluated and sieved.\n\t*/\n\tonUpdate: function onUpdate() {\n\t\tthis.events.emit('updated', this);\n\t\tthis.__log__('debug', 'State has been updated. Mutatis mutandis.');\n\t},\n\n\t/** + `expanded` after new elements are added to the state.\n\t*/\n\tonExpand: function onExpand() {\n\t\tthis.events.emit('expanded', this);\n\t\tthis.__log__('debug', 'State has been expanded. Nos exploramus.');\n\t},\n\n\t/** + `evaluated` after the elements in the state are evaluated.\n\t*/\n\tonEvaluate: function onEvaluate(elements) {\n\t\tthis.events.emit('evaluated', this, elements);\n\t\tthis.__log__('debug', 'Evaluated and sorted ', elements.length, ' elements. Appretiatus sunt.');\n\t},\n\n\t/** + `sieved` after elements are removed from the state.\n\t*/\n\tonSieve: function onSieve() {\n\t\tthis.events.emit('sieved', this);\n\t\tthis.__log__('debug', 'State has been sieved. Haec est viam.');\n\t},\n\n\t/** + `advanced` when one full iteration is completed.\n\t*/\n\tonAdvance: function onAdvance() {\n\t\tthis.events.emit('advanced', this);\n\t\tthis.__log__('debug', 'Step ', this.step, ' has been completed. Nos proficimus.');\n\t},\n\n\t/** + `analyzed` after the statistics are calculated.\n\t*/\n\tonAnalyze: function onAnalyze() {\n\t\tthis.events.emit('analyzed', this);\n\t\tthis.__log__('debug', 'Statistics have been gathered. Haec sunt numeri.');\n\t},\n\n\t/** + `finished` when the run finishes.\n\t*/\n\tonFinish: function onFinish() {\n\t\tthis.events.emit('finished', this);\n\t\tthis.__log__('debug', 'Finished. Nos invenerunt!');\n\t},\n\n\t// ## Multi-objective ##########################################################################\n\n\t/** A Pareto analysis of a set of elements compares all elements with each other, accounting the\n\tdomination relationship between the elements. Every element gets a new property `pareto`, an\n\tobject holding two arrays:\n\n\t+ `pareto.dominated` is a list of elements dominated by this element,\n\n\t+ `pareto.dominators` is a list of elements that dominate this element.\n\t*/\n\tparetoAnalysis: function paretoAnalysis(elements) {\n\t\telements = elements || this.state;\n\t\tvar len = elements.length,\n\t\t\ti1, i2, elem1, elem2, domination;\n\t\tfor (i1 = 0; i1 < len; i1++) {\n\t\t\telements[i1].pareto = { dominated: [], dominators: [] };\n\t\t}\n\t\tfor (i1 = 0; i1 < len; i1++) {\n\t\t\telem1 = elements[i1];\n\t\t\tfor (i2 = i1 + 1; i2 < len; i2++) {\n\t\t\t\telem2 = elements[i2];\n\t\t\t\tdomination = this.problem.compare(elem1, elem2).domination;\n\t\t\t\tif (domination > 0) {\n\t\t\t\t\telem1.pareto.dominated.push(elem2);\n\t\t\t\t\telem2.pareto.dominators.push(elem1);\n\t\t\t\t} else if (domination < 0) {\n\t\t\t\t\telem2.pareto.dominated.push(elem1);\n\t\t\t\t\telem1.pareto.dominators.push(elem2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn elements;\n\t},\n\n\t/** Sorting function used for multiobjective problems. By default uses `nonDominatedSort` (based\n\ton NSGA).\n\t*/\n\tmultiObjectiveSort: function multiObjectiveSort(elements) {\n\t\treturn this.nonDominatedSort(elements);\n\t},\n\n\t/** The crowding distance is an estimation of the density of elements surrounding each element\n\tin the given list (or the state by default). Every element will be added a `crowdingDistance`\n\tnumber property.\n\t*/\n\tcrowdingDistance: function crowdingDistance(elements) {\n\t\telements = elements || this.state;\n\t\tvar es = elements.slice(), // shallow copy.\n\t\t\tcount = this.problem.objectives.length,\n\t\t\ti, j;\n\t\tfor (i = 0; i < es.length; i++) {\n\t\t\tes[i].crowdingDistance = 0;\n\t\t}\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tes.sort(function (elem1, elem2) {\n\t\t\t\treturn elem1.evaluation[i] - elem2.evaluation[i];\n\t\t\t});\n\t\t\tes[0].crowdingDistance = Infinity;\n\t\t\tes[es.length - 1].crowdingDistance = Infinity;\n\t\t\tfor (j = 1; j < es.length - 1; j++) {\n\t\t\t\tes[j].crowdingDistance += es[j + 1].evaluation[i] - es[j - 1].evaluation[i];\n\t\t\t}\n\t\t}\n\t\treturn elements;\n\t},\n\n\t/** The non-dominated sort is based on [_\"A Fast Elitist Non-Dominated Sorting Genetic Algorithm\n\tfor Multi-Objective Optimization: NSGA-II\"_ by Deb (2000)](http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.18.4257).\n\t*/\n\tnonDominatedSort: function nonDominatedSort(elements) {\n\t\telements = this.paretoAnalysis(elements);\n\t\telements = this.crowdingDistance(elements);\n\t\telements.sort(function (elem1, elem2) {\n\t\t\treturn (elem1.pareto.dominators.length - elem2.pareto.dominators.length) ||\n\t\t\t\t(elem2.crowdingDistance - elem1.crowdingDistance);\n\t\t});\n\t\treturn elements;\n\t},\n\n\t/** The Pareto strength of an element is defined as the sum of the amount of elements being\n\tdominated by all dominators of a given element. For more information see: [_\"SPEA2: Improving\n\tthe Strength Pareto Evolutionary Algorithm\"_ by Zitzler et al (2001)](http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.112.5073).\n\t*/\n\tstrengthParetoSort: function strengthParetoSort(elements) {\n\t\telements = this.paretoAnalysis(elements);\n\t\titerable(elements).forEach(function (elem) {\n\t\t\telem.pareto.strength = iterable(elem.pareto.dominators).map(function (dominator) {\n\t\t\t\treturn dominator.pareto.dominated.length;\n\t\t\t}).sum();\n\t\t});\n\t\treturn elements.sort(function (elem1, elem2) { // Pareto strength must be minimized.\n\t\t\treturn elem1.pareto.strength - elem2.pareto.strength;\n\t\t});\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** The default string representation of a Metaheuristic is like `\"[object class]\"`.\n\t*/\n\ttoString: function toString() {\n\t\treturn \"[object \"+ (this.constructor.name || 'Metaheuristic') +\"]\";\n\t},\n\n\t/** Returns a reconstruction of the parameters used in the construction of this instance.\n\t*/\n\t__params__: function __params__() {\n\t\tvar params = { problem: this.problem, size: this.size, steps: this.steps };\n\t\tif (this.random !== Randomness.DEFAULT) {\n\t\t\tparams.random = this.random;\n\t\t}\n\t\tif (this.step >= 0) {\n\t\t\tparams.step = this.step;\n\t\t\tparams.state = this.state;\n\t\t\tparams.statistics = this.statistics;\n\t\t} else if (this.state.length > 0) {\n\t\t\tparams.state = this.state;\n\t\t}\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar id = arguments[i];\n\t\t\tif (this.hasOwnProperty(id)) {\n\t\t\t\tparams[id] = this[id];\n\t\t\t}\n\t\t}\n\t\treturn params;\n\t},\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'Metaheuristic',\n\t\tserializer: function serialize_Metaheuristic(obj) {\n\t\t\treturn [obj.__params__()];\n\t\t}\n\t}\n}); // declare Metaheuristic.\n","/** # Distribution estimation\n\nThis is a simple implementation of a [estimation of distributionalgorithm]\n(http://en.wikipedia.org/wiki/Estimation_of_distribution_algorithm). This stochastic optimization\nmethods try to estimate a probabilistic model for the characteristics of the better candidate\nsolutions. At each step many individual are randomly generated based on the current model. After all\nhave been evaluated, the model is adjusted.\n\nThe statistical model in this implementation is an histogram for each dimension (i.e. value of the\nelement representing the candidate solution). Dimensions are assumed to be independent of each\nother.\n*/\nvar DistributionEstimation = metaheuristics.DistributionEstimation = declare(Metaheuristic, {\n\t/** The constructor takes the following parameters:\n\t*/\n\tconstructor: function DistributionEstimation(params) {\n\t\tMetaheuristic.call(this, params);\n\t\tinitialize(this, params)\n\t\t\t/** + `histogramWidth=10` is the amounts of ranges the value domain is split in order\n\t\t\tto calculate the histograms.\n\t\t\t*/\n\t\t\t.integer('histogramWidth', { coerce: true, defaultValue: 10, minimum: 2 });\n\t},\n\n\t/** New elements to add to the state in the `expansion` are build from the `histograms`\n\tcalculated from said state.\n\t*/\n\texpansion: function expansion(size) {\n\t\tvar mh = this,\n\t\t\texpansionRate = isNaN(this.expansionRate) ? 0.5 : +this.expansionRate,\n\t\t\thistograms = this.histograms(); // Get the current histogram of the state.\n\t\tsize = isNaN(size) ? Math.floor(expansionRate * this.size) : size |0;\n\t\treturn base.Iterable.repeat(null, size).map(function () {\n\t\t\treturn mh.elementFromHistograms(histograms);\n\t\t}).toArray();\n\t},\n\n\t/** The `histograms` have the frequencies of value ranges in the current state.\n\t*/\n\thistograms: function histograms() {\n\t\treturn DistributionEstimation.histograms(this.state, this.histogramWidth,\n\t\t\tthis.problem.Element.prototype.model.length);\n\t},\n\n\t'static histograms': function histograms(state, histogramWidth, histogramCount) {\n\t\tvar size = state.length,\n\t\t\tcounts = Iterable.iterate(function (v) { // Builds a matrix of zeroes.\n\t\t\t\treturn v.slice();\n\t\t\t}, Iterable.repeat(0, histogramWidth).toArray(), histogramCount).toArray();\n\t\tstate.forEach(function (element) {\n\t\t\telement.__values__.forEach(function (value, i) {\n\t\t\t\tvar bar = Math.min(histogramWidth - 1, Math.floor(value * histogramWidth)); //FIXME Normalize.\n\t\t\t\tcounts[i][bar]++;\n\t\t\t});\n\t\t});\n\t\treturn counts.map(function (v) { // Turn counts into frequencies.\n\t\t\treturn v.map(function (v) {\n\t\t\t\treturn v / size;\n\t\t\t});\n\t\t});\n\t},\n\n\t/** The method `elementFromHistogram` is used to make these new random elements.\n\t*/\n\telementFromHistograms: function elementFromHistogram(histograms) {\n\t\treturn DistributionEstimation.elementFromHistograms(histograms, this.problem, this.random);\n\t},\n\n\t'static elementFromHistograms': function elementFromHistogram(histograms, problem, random) {\n\t\tvar length = histograms.length,\n\t\t\tvalues = new Array(length),\n\t\t\thistogram, r;\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\thistogram = histograms[i];\n\t\t\tr = random.random();\n\t\t\tfor (var j = 0; j <= histogram.length; ++j) {\n\t\t\t\tif (j === histogram.length || (r -= histogram[j]) <= 0) {\n\t\t\t\t\tvalues[i] = Math.min(1, Math.max(0, (j + random.random()) / histogram.length));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new problem.Element(values);\n\t},\n\n\t// ## Estimation of distribution as a problem. #################################################\n\n\t/** A `histogramProblem` is the problem of finding histograms that would generate good candidate\n\tsolutions for a given `problem`.\n\t*/\n\t'static histogramProblem': function histogramProblem(problem, size, histogramWidth) {\n\t\tsize = isNaN(size) ? 30 : Math.max(1, size |0);\n\t\thistogramWidth = isNaN(histogramWidth) ? 10 : Math.max(2, histogramWidth |0);\n\t\tvar elementLength = problem.elementLength(),\n\t\t\telementFromHistograms = this.elementFromHistograms;\n\t\t\tHistogramProblem = declare(Problem, {\n\t\t\t\t/** Each element of this problem represents an histogram for elements of the given\n\t\t\t\t`problem`. The argument `histogramWidth` defines how many ranges each histogram has.\n\t\t\t\t*/\n\t\t\t\telementLength: function elementLength() {\n\t\t\t\t\treturn elementLength * histogramWidth;\n\t\t\t\t},\n\n\t\t\t\t/** The evaluation of the elements is the average evaluation of `size` elements\n\t\t\t\tgenerated from the histogram that this element represents.\n\t\t\t\t*/\n\t\t\t\tevaluation: function evaluation(element) {\n\t\t\t\t\tvar histograms = this.mapping(element),\n\t\t\t\t\t\telements = base.Iterable.repeat(null, size).map(function () {\n\t\t\t\t\t\t\treturn elementFromHistograms(histograms, problem, problem.random);\n\t\t\t\t\t\t});\n\t\t\t\t\treturn Future.all(iterable(elements).map(function (e) {\n\t\t\t\t\t\treturn Future.when(e.evaluate());\n\t\t\t\t\t})).then(function (evaluations) {\n\t\t\t\t\t\treturn iterable(evaluations).sum() / evaluations.length;\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\t/** The `mapping` simply assembles the histograms and normalizes its frequencies.\n\t\t\t\t*/\n\t\t\t\tmapping: function mapping(element) {\n\t\t\t\t\tvar histograms = [],\n\t\t\t\t\t\thistogram, sum;\n\t\t\t\t\tfor (var i = 0; i < element.length; ++i) {\n\t\t\t\t\t\thistogram = element.values().slice(i * histogramWidth, (i+1) * histogramWidth);\n\t\t\t\t\t\tsum = iterable(histogram).sum();\n\t\t\t\t\t\thistograms[i] = histogram.map(function (f) { // Normalization\n\t\t\t\t\t\t\treturn f / sum;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn histograms;\n\t\t\t\t},\n\n\t\t\t\t/** The comparison function is the same as the original problem's.\n\t\t\t\t*/\n\t\t\t\tcompare: problem.compare\n\t\t\t});\n\t\treturn new HistogramProblem({ random: problem.random });\n\t},\n\n\t// ## Other ####################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'DistributionEstimation',\n\t\tserializer: function serialize_DistributionEstimation(obj) {\n\t\t\treturn [obj.__params__('histogramWidth')];\n\t\t}\n\t}\n}); // declare DistributionEstimation.\n","/** # Hill climbing\n\n[Hill Climbing](http://en.wikipedia.org/wiki/Hill_climbing) is a simple iterative local search\nmethod. The state has only one element, and in each iteration its best successor replaces it, after\na local optimum is reached.\n*/\nvar HillClimbing = metaheuristics.HillClimbing = declare(Metaheuristic, {\n\t/** The constructor The constructor takes the following parameters:\n\t*/\n\tconstructor: function HillClimbing(params) {\n\t\tMetaheuristic.call(this, params);\n\t\tinitialize(this, params)\n\t\t/** + `delta` is the radius of the elements surroundings in every dimension.\n\t\t*/\n\t\t\t.number('delta', { defaultValue: 1, coerce: true })\n\t\t/** + `size` is constrained to 1 by default. This may be increased, resulting in many\n\t\tparallel climbings.\n\t\t*/\n\t\t\t.integer('size', { defaultValue: 1, coerce: true });\n\t},\n\n\t/** The hill climbings `update()` replaces each element in the state by the best element in its\n\tneighbourhood, if there is any. The surroundings have all possible elements resulting from\n\teither an increment or decrement (of the given `delta`) in each of the centre element's\n\tdimensions.\n\t*/\n\tupdate: function update() {\n\t\tvar mh = this,\n\t\t\tlocalOptima = 0;\n\t\treturn Future.all(this.state.map(function (elem) {\n\t\t\tvar range = elem.neighbourhood(mh.delta);\n\t\t\trange.push(elem);\n\t\t\treturn Future.then(mh.evaluate(range), function (range) {\n\t\t\t\tvar best = range[0];\n\t\t\t\tif (elem === best) {\n\t\t\t\t\tlocalOptima++;\n\t\t\t\t}\n\t\t\t\treturn best;\n\t\t\t});\n\t\t})).then(function (elems) {\n\t\t\telems = mh.sort(elems);\n\t\t\tmh.state = elems;\n\t\t\tmh.__localOptima__ = localOptima;\n\t\t\tmh.onUpdate();\n\t\t});\n\t},\n\n\t/** `atLocalOptima()` checks if the search is currently stuck at a local optima.\n\t*/\n\tatLocalOptima: function atLocalOptima() {\n\t\treturn this.__localOptima__ >= this.state.length;\n\t},\n\n\t/** A hill climbing search must finish when a local optimum is reached. This criteria is tested\n\ttogether with all others.\n\t*/\n\tfinished: function finished() {\n\t\treturn Metaheuristic.prototype.finished.call(this) || this.atLocalOptima();\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'HillClimbing',\n\t\tserializer: function serialize_HillClimbing(obj) {\n\t\t\treturn [obj.__params__('delta')];\n\t\t}\n\t}\n}); // declare HillClimbing.\n","/** # Genetic algorithm\n\nClassic Holland's-style [genetic algorithms](http://en.wikipedia.org/wiki/Genetic_algorithm),\nwhich is the base for many evolutionary computing variants.\n*/\nvar GeneticAlgorithm = metaheuristics.GeneticAlgorithm = declare(Metaheuristic, {\n\t/** The constructor takes many parameters specific for this technique:\n\t*/\n\tconstructor: function GeneticAlgorithm(params) {\n\t\tMetaheuristic.call(this, params); // Superconstructor call.\n\t\tinitialize(this, params)\n\t\t/** + `expansionRate=0.5` is the amount of new elements generated by crossover, as a ratio\n\t\tof the population size.\n\t\t*/\n\t\t\t.number('expansionRate', { defaultValue: 0.5, minimum: 0, coerce: true })\n\t\t/** + `mutationRate=0.2` is the chance of a new element (resulting from crossover) mutating.\n\t\t*/\n\t\t\t.number('mutationRate', { defaultValue: 0.2, minimum: 0, maximum: 1, coerce: true })\n\t\t/** + `selection(count)` is a function that selects count elements from the current\n\t\tpopulation. These will be the parents of the new elements in the next generation. By default\n\t\trank selection is used, a.k.a. fitness proportional to position in the state.\n\t\t*/\n\t\t\t.func('selection', { defaultValue: GeneticAlgorithm.selections.rankSelection })\n\t\t/** + `crossover(parents)` is a function implementing the genetic operator that simulates\n\t\treproduction with inheritance. The parents argument must be an array of elements. The result\n\t\tis an array of elements. By default the single point crossover is used.\n\t\t*/\n\t\t\t.func('crossover', { defaultValue: GeneticAlgorithm.crossovers.singlepointCrossover })\n\t\t/** `mutation(element)` is a function implementing the genetic operator that simulates\n\t\tbiological mutation, making a random change in the chromosome. By default a single point\n\t\tuniform mutation is used.\n\t\t*/\n\t\t\t.func('mutation', { defaultValue: GeneticAlgorithm.mutations.singlepointUniformMutation });\n\t},\n\n\t/** The population's (state) `expansion()` is the possibly mutated crossovers of selected\n\telements. How many is determined by `expansionRate`.\n\t*/\n\texpansion: function expansion() {\n\t\tvar parents, childs, child,\n\t\t\tnewElements = [],\n\t\t\tlen = Math.floor(this.expansionRate * this.size);\n\t\tlen += len % 2; // Make len even.\n\t\tfor (var i = 0; i < len; i += 2) {\n\t\t\tparents = this.selection();\n\t\t\tchilds = this.crossover(parents);\n\t\t\tfor (var j = 0; j < childs.length; j++) {\n\t\t\t\tchild = this.random.randomBool(this.mutationRate) ? this.mutation(childs[j]) : childs[j];\n\t\t\t\tnewElements.push(child);\n\t\t\t}\n\t\t}\n\t\tthis.onExpand();\n\t\treturn newElements;\n\t},\n\n\t/** ## Selection methods #######################################################################\n\n\t`GeneticAlgorithm.selections` is a bundle of standard selection methods. A selection function\n\ttakes the amount of elements to be selected and returns an array of selected elements. The\n\timplemented methods are:\n\t*/\n\t'static selections': {\n\t\t/** + `rankSelection(count=2)` makes a selection where each element's probability of being\n\t\tselected is proportional to its position in the state.\n\t\t*/\n\t\trankSelection: function rankSelection(count) {\n\t\t\tcount = isNaN(count) ? 2 : +count;\n\t\t\tvar len = this.state.length,\n\t\t\t\trandoms = this.random.randoms(count, 0, len * (len + 1) / 2 - 1),\n\t\t\t\tselected = [];\n\t\t\trandoms.sort(function (x, y) {\n\t\t\t\treturn x - y;\n\t\t\t});\n\t\t\tthis.state.forEach(function (element) {\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\trandoms[i] += i - len;\n\t\t\t\t}\n\t\t\t\tif (randoms[0] <= 0) {\n\t\t\t\t\tselected.push(element);\n\t\t\t\t\trandoms.shift();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (selected.length < count) { // Should not happen.\n\t\t\t\tselected = selected.concat(this.state.slice(0, count - selected.length));\n\t\t\t}\n\t\t\treturn selected;\n\t\t},\n\n\t\t/** + `rouletteSelection(count=2)` makes a selection where each element's probability of being\n\t\tselected is proportional to its evaluation. Warning! This selection assumes the evaluation is\n\t\tbeing maximized.\n\t\t*/\n\t\trouletteSelection: function rouletteSelection(count) { //FIXME\n\t\t\tcount = isNaN(count) ? 2 : count |0;\n\t\t\tvar len = this.state.length,\n\t\t\t\tevaluationStat = this.statistics.stat({key: 'evaluation', step: this.step}),\n\t\t\t\tmin = evaluationStat.minimum(),\n\t\t\t\tsum = evaluationStat.sum(),\n\t\t\t\trandoms = this.random.randoms(count, 0, sum - len * min),\n\t\t\t\tselected = [];\n\t\t\trandoms.sort(function (x, y) { return x-y; });\n\t\t\tthis.state.forEach(function (element) {\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\trandoms[i] += i - len;\n\t\t\t\t}\n\t\t\t\tif (randoms[0] <= 0) {\n\t\t\t\t\tselected.push(element);\n\t\t\t\t\trandoms.shift();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (selected.length < count) { // Should not happen.\n\t\t\t\tselected = selected.concat(this.state.slice(0, count - selected.length));\n\t\t\t}\n\t\t\treturn selected;\n\t\t},\n\n\t\t/** + [`stochasticUniversalSamplingSelection(count)`](http://en.wikipedia.org/wiki/Stochastic_universal_sampling)\n\t\tis a less biased version of the roulette selection method.\n\t\t*/\n\t\tstochasticUniversalSamplingSelection: function stochasticUniversalSamplingSelection(count) {\n\t\t\tcount = isNaN(count) ? 2 : count |0;\n\t\t\tvar state = this.state,\n\t\t\t\ttotalFitness = iterable(state).select('evaluation').sum(),\n\t\t\t\tp = totalFitness / count;\n\t\t\treturn base.Iterable.iterate(function (x) {\n\t\t\t\treturn x + p;\n\t\t\t}, this.random.randomInt(p), count).map(function (pointer) {\n\t\t\t\tvar sum = 0;\n\t\t\t\tfor (var i = 0; i < state.length; ++i) {\n\t\t\t\t\tsum += state[i].evaluation;\n\t\t\t\t\tif (sum >= pointer) {\n\t\t\t\t\t\treturn state[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn state[state.length - 1]; // Very improbable.\n\t\t\t}).toArray();\n\t\t},\n\t}, // GeneticAlgorithm.selections\n\n\t/** ## Crossover methods #######################################################################\n\n\t`GeneticAlgorithm.crossovers` is a bundle of standard crossover methods. A crossover function\n\ttakes an array of parent elements and returns an array of sibling elements. The implemented\n\tmethods are:\n\t*/\n\t'static crossovers': {\n\t\t/** + `singlepointCrossover(parents)` given two parents returns an array of two new elements\n\t\tbuilt with one half of each parent. The cutpoint is chosen randomly.\n\t\t*/\n\t\tsinglepointCrossover: function singlepointCrossover(parents) {\n\t\t\traiseIf(!Array.isArray(parents) || parents.length < 2, \"A two parent array is required.\");\n\t\t\tvar cut = this.random.randomInt(this.length - 1) + 1,\n\t\t\t\tvalues0 = parents[0].values(),\n\t\t\t\tvalues1 = parents[1].values();\n\t\t\treturn [\n\t\t\t\tnew this.problem.Element(values0.slice(0, cut).concat(values1.slice(cut))),\n\t\t\t\tnew this.problem.Element(values1.slice(0, cut).concat(values0.slice(cut)))\n\t\t\t];\n\t\t},\n\n\t\t/** + `twopointCrossover(parents)` given two parents returns an array of two new elements:\n\t\tthe first one with two parts of the first parent and one part of the second parent, and the\n\t\tsecond one assembled viceversa. The two cutpoints are chosen randomly.\n\t\t*/\n\t\ttwopointCrossover: function twopointCrossover(parents) {\n\t\t\traiseIf(!Array.isArray(parents) || parents.length < 2,\n\t\t\t\t\"A two parent array is required.\");\n\t\t\tvar cut1 = this.random.randomInt(this.length - 1) + 1,\n\t\t\t\tcut2 = this.random.randomInt(this.length - 1) + 1,\n\t\t\t\tvalues0 = parents[0].values(),\n\t\t\t\tvalues1 = parents[1].values();\n\t\t\treturn [\n\t\t\t\tnew this.problem.Element(values0.slice(0, cut1)\n\t\t\t\t\t.concat(values1.slice(cut1, cut2)).concat(values0.slice(cut2))),\n\t\t\t\tnew this.problem.Element(values1.slice(0, cut1)\n\t\t\t\t\t.concat(values0.slice(cut1, cut2)).concat(values1.slice(cut2)))\n\t\t\t];\n\t\t},\n\n\t\t/** + `uniformCrossover(parents)` creates as many children as the given parents, with each\n\t\tvalue taken randomly from any of the parents.\n\t\t*/\n\t\tuniformCrossover: function uniformCrossover(parents, count) {\n\t\t\tcount = isNaN(count) ? parents.length : count|0;\n\t\t\tvar result = [],\n\t\t\t\tlength = this.problem.elementLength(),\n\t\t\t\trandom = this.random,\n\t\t\t\tvalues;\n\t\t\tfor (var i = 0; i < count; ++i) {\n\t\t\t\tvalues = [];\n\t\t\t\tfor (var j = 0; j < length; ++j) {\n\t\t\t\t\tvalues.push(random.choice(parents).values[j]);\n\t\t\t\t}\n\t\t\t\tresult.push(new this.problem.Element(values));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}, // GeneticAlgorithm.crossovers\n\n\t/** ## Mutation methods ########################################################################\n\n\t`GeneticAlgorithm.mutations` is a bundle of standard mutation methods. A mutation function takes\n\tan element and returns a new element which is a variation of the former. The implemented methods\n\tare:\n\t*/\n\t'static mutations': {\n\t\t/** + `singlepointUniformMutation(element)` sets a randomly selected gene to a uniform\n\t\trandom value.\n\t\t*/\n\t\tsinglepointUniformMutation: function singlepointUniformMutation(element) {\n\t\t\tvar i = this.random.randomInt(element.__values__.length);\n\t\t\treturn element.modification(i, element.randomValue(i));\n\t\t},\n\n\t\t/** + `uniformMutation(maxPoints=Infinity)` builds a mutation function that makes at least\n\t\tone and up to `maxPoints` mutations, changing a randomly selected gene to a uniform random\n\t\tvalue.\n\t\t*/\n\t\tuniformMutation: function uniformMutation(maxPoints) {\n\t\t\tmax = isNaN(maxPoints) ? Infinity : +maxPoints;\n\t\t\tvar model = this.problem.elementModel();\n\t\t\treturn function mutation(element) {\n\t\t\t\tvar times = maxPoints, i, range;\n\t\t\t\telement = new this.problem.Element(element.__values__); // Copy element.\n\t\t\t\tdo {\n\t\t\t\t\ti = this.random.randomInt(model.length);\n\t\t\t\t\telement.values[i] = this.random.randomInt(0, model[i].n);\n\t\t\t\t} while (this.random.randomBool(this.mutationRate) && --times > 0);\n\t\t\t\treturn element;\n\t\t\t};\n\t\t},\n\n\t\t/** + `singlepointBiasedMutation(element)` sets a randomly selected gene to random deviation\n\t\tof its value, with a triangular distribution.\n\t\t*/\n\t\tsinglepointBiasedMutation: function singlepointBiasedMutation(element) {\n\t\t\tvar random = this.random,\n\t\t\t\tmodel = this.problem.elementModel(),\n\t\t\t\ti = random.randomInt(element.length);\n\t\t\treturn element.modification(i, element.__values__[i] +\n\t\t\t\t(random.random() - random.random()) * model[i].n);\n\t\t},\n\n\t\t/** + `recombinationMutation(element)` swaps two values of the element at random.\n\t\t*/\n\t\trecombinationMutation: function recombinationMutation(element) {\n\t\t\tvar values = element.__values__.slice(),\n\t\t\t\ti1 = this.random.randomInt(values.length),\n\t\t\t\tv1 = values[i1],\n\t\t\t\ti2 = this.random.randomInt(values.length), v2;\n\t\t\tif (i1 === i2) {\n\t\t\t\ti2 = (i2 + 1) % element.length;\n\t\t\t}\n\t\t\tvalues[i1] = values[i2];\n\t\t\tvalues[i2] = v1;\n\t\t\treturn new this.problem.Element(values);\n\t\t}\n\t}, // GeneticAlgorithm.mutations\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'GeneticAlgorithm',\n\t\tserializer: function serialize_GeneticAlgorithm(obj) {\n\t\t\tvar params = obj.__params__('expansionRate', 'mutationRate');\n\t\t\t//TODO serialize 'selection', 'crossover', 'mutation'\n\t\t\treturn [params];\n\t\t}\n\t}\n}); // declare GeneticAlgorithm.\n","/** # Beam search\n\n[Beam search](http://en.wikipedia.org/wiki/Beam_search) is a form of parallel best-first search with \nlimited memory.\n*/\nvar BeamSearch = metaheuristics.BeamSearch = declare(Metaheuristic, {\n\t/** The constructor m take any special parameters.\n\t*/\n\tconstructor: function BeamSearch(params) {\n\t\tMetaheuristic.call(this, params);\n\t\tinitialize(this, params)\n\t\t\t/** A `delta` may be specified for the default `successors` for continuous variables.\n\t\t\t*/\n\t\t\t.number('delta', { ignore: true, coerce: true });\n\t},\n\t\n\t/** `successors(element)` returns the elements' successors. The problem's element must have its \n\t`successors` method implemented.\n\t*/\n\tsuccessors: function successors(element) {\n\t\treturn element.neighbourhood(this.delta);\n\t},\n\t\n\t/** The expansion in beam search adds all successors of all elements to the\tstate. After being \n\tevaluated and sieved only the best will remain.\n\t*/\n\texpansion: function expansion() {\n\t\tvar allSuccessors = [],\n\t\t\tsuccessors = this.successors.bind(this);\n\t\tthis.state.forEach(function (element) {\n\t\t\tallSuccessors = allSuccessors.concat(successors(element));\n\t\t});\n\t\tthis.onExpand();\n\t\treturn allSuccessors;\n\t},\n\t\n\t// ## Utilities ################################################################################\n\t\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'BeamSearch',\n\t\tserializer: function serialize_BeamSearch(obj) {\n\t\t\treturn [obj.__params__('delta')];\n\t\t}\n\t}\n}); // declare BeamSearch.\n","/** # Simulated annealing\n\n[Simulated annealing](http://en.wikipedia.org/wiki/Simulated_annealing) is a stochastic global\noptimization technique.\n*/\nvar SimulatedAnnealing = metaheuristics.SimulatedAnnealing = declare(Metaheuristic, {\n\t/** The constructor takes some specific parameters for this search:\n\t*/\n\tconstructor: function SimulatedAnnealing(params) {\n\t\tMetaheuristic.call(this, params);\n\t\tinitialize(this, params)\n\t\t/** + `maximumTemperature=1` is the temperature at the start of the run.\n\t\t*/\n\t\t\t.number('maximumTemperature', { defaultValue: 1, coerce: true })\n\t\t/** + `minimumTemperature=0` is the temperature at the end of the run.\n\t\t*/\n\t\t\t.number('minimumTemperature', { defaultValue: 0, coerce: true })\n\t\t/** + `delta=1` is the radius of the elements surroundings in every dimension, that is\n\t\tchecked by this algorithm.\n\t\t*/\n\t\t\t.number('delta', { defaultValue: 1, coerce: true })\n\t\t/** + `size=1` is 1 by default, but larger states are supported.\n\t\t*/\n\t\t\t.integer('size', { defaultValue: 1,\tcoerce: true })\n\t\t/** + `temperature=coolingSchedule.linear` is the temperature function.\n\t\t*/\n\t\t\t.func('temperature', { defaultValue: this.coolingSchedule.linear });\n\t},\n\n\t/** `randomNeighbour(element, radius=this.delta)` returns one neighbour of the given element\n\tchosen at random.\n\t*/\n\trandomNeighbour: function randomNeighbour(element, radius) {\n\t\tradius = isNaN(radius) ? this.delta : +radius;\n\t\tvar i = this.random.randomInt(element.model.length),\n\t\t\tv = element.__values__[i];\n\t\treturn element.modification(i, \n\t\t\tclamp(this.random.randomBool() ? v + radius : v - radius, 0, element.model[i].n - 1)\n\t\t);\n\t},\n\n\t/** The `acceptance(current, neighbour, temp=this.temperature())` is the probability of\n\taccepting the new element. Uses the original definitions from\n\t[Kirkpatrick's paper](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.123.7607).\n\t*/\n\tacceptance: function acceptance(current, neighbour, temp) {\n\t\ttemp = isNaN(temp) ? this.temperature() : +temp;\n\t\tif (neighbour.isBetterThan(current)) {\n\t\t\treturn 1; // Should always accept a better neighbour.\n\t\t} else {\n\t\t\tvar d = -Math.abs(neighbour.evaluation - current.evaluation);\n\t\t\treturn clamp(Math.exp(d / temp), 0, 1);\n\t\t}\n\t},\n\n\t/** The annealings temperature is a metaphore for the amount of randomness the process applies.\n\tThe cooling schedule is a function that calculates the temperature for any given step in the\n\toptimization.\n\t*/\n\tcoolingSchedule: {\n\t\tlinear: function temperature() {\n\t\t\treturn (1 - Math.max(0, this.step) / this.steps) *\n\t\t\t\t(this.maximumTemperature - this.minimumTemperature) + this.minimumTemperature;\n\t\t}\n\t},\n\n\t/** At every iteration, for each element in the state one of its neighbours is chosen randomly.\n\tIf the neighbour is better, it replaces the corresponding element. Else it may still do so, but\n\twith a probability calculated by `acceptance()`.\n\t*/\n\tupdate: function update() {\n\t\tvar mh = this,\n\t\t\ttemp = this.temperature(),\n\t\t\tacceptanceStat = this.statistics.stat({key: 'acceptance'}),\n\t\t\ttemperatureStat = this.statistics.stat({key: 'temperature'});\n\t\ttemperatureStat.add(temp, this.step);\n\t\treturn Future.all(this.state.map(function (elem) {\n\t\t\tvar neighbour = mh.randomNeighbour(elem);\n\t\t\treturn Future.then(neighbour.evaluate(), function () {\n\t\t\t\tvar p = mh.acceptance(elem, neighbour, temp);\n\t\t\t\tacceptanceStat.add(p, neighbour);\n\t\t\t\treturn mh.random.randomBool(p) ? neighbour : elem;\n\t\t\t});\n\t\t})).then(function (elems) {\n\t\t\telems = mh.sort(elems);\n\t\t\tmh.state = elems;\n\t\t\tmh.onUpdate();\n\t\t\treturn mh;\n\t\t});\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'SimulatedAnnealing',\n\t\tserializer: function serialize_SimulatedAnnealing(obj) {\n\t\t\t//TODO Serialize 'temperature'\n\t\t\treturn [obj.__params__('maximumTemperature', 'minimumTemperature', 'delta')];\n\t\t}\n\t}\n}); // declare SimulatedAnnealing.\n","/** # Particle swarm\n\n[Particle Swarm](http://en.wikipedia.org/wiki/Particle_swarm_optimization) is an stochastic\noptimization technique. Every candidate solution is treated as a particle with a position and a\nvelocity. On each iteration the positions and velocities of every particle are updated considering\nthe best positions so far.\n*/\nvar ParticleSwarm = metaheuristics.ParticleSwarm = declare(Metaheuristic, {\n\t/** The constructor takes some specific parameters for this search:\n\t*/\n\tconstructor: function ParticleSwarm(params) {\n\t\tMetaheuristic.call(this, params);\n\t\tinitialize(this, params)\n\t\t/** + `inertia=1` is the weight of the particle's current velocity in the velocity update.\n\t\t*/\n\t\t\t.number('inertia', { defaultValue: 1, coerce: true })\n\t\t/** + `localAcceleration=0.5` is the weight of the particle's current best position in the\n\t\t\t\tvelocity update.\n\t\t*/\n\t\t\t.number('localAcceleration', { defaultValue: 0.5, coerce: true })\n\t\t/** + `globalAcceleration=0.3` is the weight of the whole swarm's current best position in\n\t\t\t\tthe velocity update.\n\t\t*/\n\t\t\t.number('globalAcceleration', { defaultValue: 0.3, coerce: true });\n\t},\n\n\t/** The elements in a particle swarm have two added properties which have to be initialized:\n\n\t+ `__velocity__` is the vector that defines the movement of the particle. Initially it is a\n\t\trandom vector.\n\t+ `__localBest__` is the best position of the particle in the run. The first position has\n\t\titself as the best so far.\n\t*/\n\tinitiate: function initiate(size) {\n\t\tMetaheuristic.prototype.initiate.call(this, size);\n\t\tvar mh = this,\n\t\t\tresult = this.state.forEach(function (element) {\n\t\t\t\tvar model = element.model;\n\t\t\t\telement.__velocity__ = mh.random.randoms(model.length, -1, +1).map(function (v, i) {\n\t\t\t\t\treturn v * model[i].n;\n\t\t\t\t});\n\t\t\t\telement.__localBest__ = element;\n\t\t\t});\n\t\tthis.onInitiate();\n\t\treturn result;\n\t},\n\n\t/** The method `nextVelocity` calculates the velocity of the particle for the next iteration.\n\t*/\n\tnextVelocity: function nextVelocity(element, globalBest) {\n\t\tvar mh = this,\n\t\t\tvelocity = element.__velocity__,\n\t\t\tlocalBest = element.__localBest__,\n\t\t\tlocalCoef = this.random.random(this.localAcceleration),\n\t\t\tglobalCoef = this.random.random(this.globalAcceleration),\n\t\t\tresult = element.values().map(function (v, i) {\n\t\t\t\treturn velocity[i] * mh.inertia +\n\t\t\t\t\tlocalCoef * (localBest.__values__[i] - v) +\n\t\t\t\t\tglobalCoef * (globalBest.__values__[i] - v);\n\t\t\t});\n\t\treturn result;\n\t},\n\n\t/** The method `nextElement` creates a new element which represents the position of a particle\n\tin the next iteration.\n\t*/\n\tnextElement: function nextElement(element, globalBest) {\n\t\tvar mh = this,\n\t\t\tmodel = element.model,\n\t\t\tnextVelocity = this.nextVelocity(element, globalBest),\n\t\t\tnextValues = element.values().map(function (v, i) {\n\t\t\t\treturn clamp(v + nextVelocity[i], 0, model[i].n - 1);\n\t\t\t}),\n\t\t\tresult = new this.problem.Element(nextValues);\n\t\treturn Future.then(result.evaluate(), function () {\n\t\t\tresult.__velocity__ = nextVelocity;\n\t\t\tresult.__localBest__ = result.isBetterThan(element.__localBest__) ? result : element.__localBest__;\n\t\t\treturn result;\n\t\t});\n\t},\n\n\t/** Updating the optimization state means updating each particle velocity and recalculating\n\ttheir positions. The best position of the whole run is stored in the `__globalBest__` property,\n\tand updated every time a new best position is achieved. If nothing fails, in the end the\n\tparticles should converge at this position.\n\t*/\n\tupdate: function update() {\n\t\tvar mh = this,\n\t\t\tglobalBest = this.__globalBest__;\n\t\tif (!globalBest) {\n\t\t\tglobalBest = this.__globalBest__ = this.state[0];\n\t\t}\n\t\treturn Future.all(this.state.map(function (element) {\n\t\t\treturn mh.nextElement(element, globalBest);\n\t\t})).then(function (elements) {\n\t\t\telements = mh.sort(elements);\n\t\t\tmh.state = elements;\n\t\t\tif (mh.problem.compare(mh.__globalBest__, elements[0]) < 0) {\n\t\t\t\tmh.__globalBest__ = elements[0];\n\t\t\t}\n\t\t\tmh.onUpdate();\n\t\t\treturn mh;\n\t\t});\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'ParticleSwarm',\n\t\tserializer: function serialize_ParticleSwarm(obj) {\n\t\t\treturn [obj.__params__('inertia', 'localAcceleration', 'globalAcceleration')];\n\t\t}\n\t}\n}); // declare ParticleSwarm.\n","/** # Differential evolution\n\n[Differential evolution](http://en.wikipedia.org/wiki/Differential_evolution) is an evolutionary\nmetaheuristic based on a particular form of crossover. This operator acts on individual values of\neach state, replacing the value with a combination of the corresponding value in three other\nrandomly chosen elements.\n*/\nvar DifferentialEvolution = metaheuristics.DifferentialEvolution = declare(Metaheuristic, {\n\t/** The constructor takes the following parameters:\n\t*/\n\tconstructor: function DifferentialEvolution(params) {\n\t\tMetaheuristic.call(this, params);\n\t\tinitialize(this, params)\n\t\t\t/** + `differentialWeight=1` is the coefficient (usually named `F`) in the crossover\n\t\t\tformula.\n\t\t\t*/\n\t\t\t.number('differentialWeight', { coerce: true, defaultValue: 1, minimum: 0, maximum: 2 })\n\t\t\t/** + `crossoverProbability=30%` is the probability of getting a value from a crossover.\n\t\t\t*/\n\t\t\t.number('crossoverProbability', { coerce: true, defaultValue: 0.3, minimum: 0, maximum: 1 })\n\t\t\t/** Also, the state's size is constrained to a minimum of 4, because of how the\n\t\t\tcrossover works.\n\t\t\t*/\n\t\t\t.integer('size', { coerce: true, defaultValue: 100, minimum: 4 });\n\t},\n\n\t/** The expansion is quite simple. For each element `x` in the state a new one is generated.\n\tThree other elements are randomly selected from the state, named `a`, `b` and `c`. With a\n\tprobability of `crossoverProbability`, the ith value of the new element results from\n\t`a[i] + F(b[i] - c[i])`, where `F` is the `differentialWeight`. The other values are copied from\n\t`x`, although it is assured that at least one of the new element's is calculated as shown\n\tbefore.\n\t*/\n\texpansion: function expansion() {\n\t\tvar mh = this,\n\t\t\tresult = this.state.map(function (element, elementIndex) {\n\t\t\t\tvar model = element.model,\n\t\t\t\t\tstateCopy = mh.state.slice();\n\t\t\t\tstateCopy.splice(elementIndex, 1);\n\t\t\t\tvar crossover = mh.random.choices(3, stateCopy),\n\t\t\t\t\ta = crossover[0].__values__,\n\t\t\t\t\tb = crossover[1].__values__,\n\t\t\t\t\tc = crossover[2].__values__,\n\t\t\t\t\tlen = element.__values__.length,\n\t\t\t\t\trandomIndex = mh.random.randomInt(len),\n\t\t\t\t\tnewValues = element.values().map(function (value, i) {\n\t\t\t\t\t\tif (i === randomIndex || mh.random.randomBool(mh.crossoverProbability)) {\n\t\t\t\t\t\t\treturn clamp(a[i] + mh.differentialWeight * (b[i] - c[i]),\n\t\t\t\t\t\t\t\t0, model[i].n - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\treturn new mh.problem.Element(newValues);\n\t\t\t});\n\t\tthis.onExpand();\n\t\treturn result;\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'DifferentialEvolution',\n\t\tserializer: function serialize_DifferentialEvolution(obj) {\n\t\t\treturn [obj.__params__('differentialWeight', 'crossoverProbability')];\n\t\t}\n\t}\n}); // declare DifferentialEvolution.\n","/** # Evolution strategy.\n\n[Evolution strategy](https://en.wikipedia.org/wiki/Evolution_strategy) is maybe the simplest\nevolutionary optimization method. At each step, one or more random deviations of each element are\ngenerated, replacing their parent if they prove to be better.\n*/\nvar EvolutionStrategy = metaheuristics.EvolutionStrategy = declare(Metaheuristic, {\n\t/** The constructor takes the following parameters:\n\t*/\n\tconstructor: function EvolutionStrategy(params) {\n\t\tMetaheuristic.call(this, params);\n\t\tinitialize(this, params)\n\t\t\t/** + `mutantCount=1` is the number of mutants generated per element at each step.\n\t\t\t*/\n\t\t\t.number('mutantCount', { coerce: true, defaultValue: 1, minimum: 1 })\n\t\t\t/** + `size=1`: state's size is 1 by default in this metaheuristic.\n\t\t\t*/\n\t\t\t.integer('size', { coerce: true, defaultValue: 1, minimum: 1 });\n\t},\n\n\t/** A `mutant` is a new random variation of the given `element`. Although using a normal\n\tdistribution is more common, here a more efficient tringular distribution is used.\n\t*/\n\tmutant: function mutant(element) {\n\t\tvar random = this.random,\n\t\t\tmodel = element.model,\n\t\t\tnewValues = element.values().map(function (v, i) {\n\t\t\t\tvar n = model[i].n;\n\t\t\t\treturn clamp(v + (random.random() - random.random()) * n, 0, n - 1);\n\t\t\t});\n\t\treturn new this.problem.Element(newValues);\n\t},\n\n\t/** `mutants` calculates an array of `count` mutants, or `this.mutantCount` by default.\n\t*/\n\tmutants: function mutants(element, count) {\n\t\tcount = isNaN(count) ? this.mutantCount : +count;\n\t\tvar result = [];\n\t\tfor (var i = 0; i < count; ++i) {\n\t\t\tresult.push(this.mutant(element));\n\t\t}\n\t\treturn result;\n\t},\n\n\t/** The expansion simply returns a set of `this.mutantCount` mutants for each element in the\n\tcurrent state.\n\t*/\n\texpansion: function expansion() {\n\t\tvar mh = this,\n\t\t\tnewElements = [];\n\t\tthis.state.forEach(function (element) {\n\t\t\tnewElements = newElements.concat(mh.mutants(element));\n\t\t});\n\t\tthis.onExpand();\n\t\treturn newElements;\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'DistributionEstimation',\n\t\tserializer: function serialize_DistributionEstimation(obj) {\n\t\t\treturn [obj.__params__('mutantCount')];\n\t\t}\n\t}\n}); // declare EvolutionStrategy.\n","/** # Harmony search.\n\n[Harmony search](https://en.wikipedia.org/wiki/Harmony_search) is an optimization technique inspired\nby the improvisation process of musicians proposed by Zong Woo Geem in 2001.\n*/\nvar HarmonySearch = metaheuristics.HarmonySearch = declare(Metaheuristic, {\n\t/** The constructor takes the following parameters:\n\t*/\n\tconstructor: function HarmonySearch(params) {\n\t\tMetaheuristic.call(this, params);\n\t\tinitialize(this, params)\n\t\t\t/** + `harmonyProbability=90%` or _hmcr_ is the chance of a value of the next element\n\t\t\tbeing taken from one existing element in the state (or _\"harmony memory\"_).\n\t\t\t*/\n\t\t\t.number('harmonyProbability', { coerce: true, defaultValue: 0.9, minimum: 0, maximum: 1 })\n\t\t\t/** + `adjustProbability=30%` or _par_ is the chance of adjusting a value of the next\n\t\t\telement.\n\t\t\t*/\n\t\t\t.number('adjustProbability', { coerce: true, defaultValue: 0.5, minimum: 0, maximum: 1 })\n\t\t\t/** + `delta=1` is the distance between neighbouring states for discrete adjustments.\n\t\t\t*/\n\t\t\t.number('delta', { coerce: true, defaultValue: 1 })\n\t\t\t/** + `fretWidth=0.01` is the maximum adjustment for continuous variables, expressed as\n\t\t\ta ratio of the range.\n\t\t\t*/\n\t\t\t.number('fretWidth', { coerce: true, defaultValue: 0.01 })\n\t\t;\n\t},\n\n\t/** At each step only one new element is generated. Each of its values is taken from another\n\telement in the state with a chance equal to `harmonyProbability`, else it is defined at random.\n\tIf the value comes from another element, it is slightly modified by `delta` with a chance equal\n\tto `adjustProbability`.\n\t*/\n\texpansion: function expansion() {\n\t\tvar mh = this,\n\t\t\trandom = this.random,\n\t\t\tmodel = this.problem.Element.prototype.model,\n\t\t\tvalues = model.map(function (range, i) {\n\t\t\t\tif (random.randomBool(mh.harmonyProbability)) {\n\t\t\t\t\tvar value = random.choice(mh.state).__values__[i];\n\t\t\t\t\tif (random.randomBool(mh.adjustProbability)) {\n\t\t\t\t\t\tvalue += random.randomBool(0.5) ? -mh.delta : mh.delta;\n\t\t\t\t\t\t/*FIXME case for continuous variables\n\t\t\t\t\t\t\tvar span = range.n;\n\t\t\t\t\t\t\tvalue += random.random(-span, +span) * mh.fretWidth;\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t\treturn clamp(value, 0, range.n - 1);\n\t\t\t\t} else {\n\t\t\t\t\treturn random.randomInt(0, range.n) |0;\n\t\t\t\t}\n\t\t\t});\n\t\tthis.onExpand();\n\t\treturn [new this.problem.Element(values)];\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'HarmonySearch',\n\t\tserializer: function serialize_HarmonySearch(obj) {\n\t\t\treturn [obj.__params__('harmonyProbability', 'adjustProbability', 'delta', 'fretWidth')];\n\t\t}\n\t}\n}); // declare HarmonySearch.\n","/** # Gradient descent\n\n[Gradient descent](http://en.wikipedia.org/wiki/Gradient_descent) is an iterative optimization\nmethod, similar to Hill Climbing. The candidate solution is treated as a point in a multidimensional\nsearch space, and the gradient that the function being optimized defines in said domain is used to\nmove the current solution in the steepest direction.\n*/\nvar GradientDescent = metaheuristics.GradientDescent = declare(Metaheuristic, {\n\t/** The constructor takes the following parameters:\n\t*/\n\tconstructor: function HillClimbing(params) {\n\t\tMetaheuristic.call(this, params);\n\t\tinitialize(this, params)\n\t\t/** + `delta=1`: the maximum distance considered by gradient estimators.\n\t\t*/\n\t\t\t.number('delta', { coerce: true, defaultValue: 1 })\n\t\t/** + `size=1`: the state's size is 1 by default. This may be increased, resulting in many\n\t\tparallel descents.\n\t\t*/\n\t\t\t.integer('size', { coerce: true, defaultValue: 1, minimum: 1 });\n\t},\n\n\t/** A `gradient` is the vector for the direction of steepest descent (or ascent) of the function\n\tto be optimized at the given `element`. If the function is not differentiable an approximation\n\tcan be used. Since estimators may require element evaluation, which can be asynchronous, it must\n\tbe considered that this function may return a future.\n\n\tThe default implementation is based on the finite difference method proposed by [Kiefer and\n\tWolfowitz](http://projecteuclid.org/euclid.aoms/1177729392).\n\t*/\n\tgradient: function gradient(element) {\n\t\treturn this.gradientFiniteDifferences(element);\n\t},\n\n\t/** The `rate` is a number by which the gradient is multiplied before adding it to the current\n\tpoint to advance to the next step. The default implementation returns `1/step`, as [Kiefer and\n\tWolfowitz suggest](http://projecteuclid.org/euclid.aoms/1177729392).\n\t*/\n\trate: function rate(step) {\n\t\tstep = isNaN(step) ? this.step : step |0;\n\t\treturn 1 / Math.max(1, step);\n\t},\n\n\t/** The `estimatorWidth` is a number used by some gradient estimators. By default it returns\n\t`step^(-1/3) * delta`, similar to what [Kiefer and Wolfowitz suggest](http://projecteuclid.org/euclid.aoms/1177729392).\n\t*/\n\testimatorWidth: function estimatorWidth(step, delta) {\n\t\tstep = isNaN(step) ? this.step : step |0;\n\t\tdelta = isNaN(delta) ? this.delta : +delta;\n\t\treturn Math.pow(Math.max(1, step), -1/3) * delta;\n\t},\n\n\t/** In the `update`, each element in the state is moved in the search domain. The movement is\n\tset by its gradient in the direction of the optimization. The distance is defined by the `rate`\n\tfor the current step.\n\t*/\n\tupdate: function update() {\n\t\tvar mh = this,\n\t\t\trate = this.rate(this.step);\n\t\treturn Future.all(this.state.map(function (elem) {\n\t\t\tvar model = elem.model;\n\t\t\treturn Future.then(mh.gradient(elem), function (gradient) {\n\t\t\t\tvar newValues = gradient.map(function (gradientValue, i) {\n\t\t\t\t\treturn clamp(elem.__values__[i] - gradientValue * rate, 0, model[i].n - 1);\n\t\t\t\t});\n\t\t\t\treturn new mh.problem.Element(newValues);\n\t\t\t});\n\t\t})).then(function (elems) {\n\t\t\treturn mh.evaluate(elems);\n\t\t}).then(function (elems) {\n\t\t\tmh.state = elems;\n\t\t\tmh.onUpdate();\n\t\t\treturn mh;\n\t\t});\n\t},\n\n\t// ## Gradient estimators ######################################################################\n\n\t/** A gradient estimator at the given `element` by finite differences.\n\t*/\n\tgradientFiniteDifferences: function gradientFiniteDifferences(element, width) {\n\t\twidth = isNaN(width) ? this.estimatorWidth() : +width;\n\t\tvar mh = this,\n\t\t\tvalues = element.values();\n\t\treturn Future.all(values.map(function (value, i) {\n\t\t\tvar left = element.modification(i, value - width),\n\t\t\t\tright = element.modification(i, value + width);\n\t\t\treturn Future.then(left.evaluate(), function (leftEvaluation) {\n\t\t\t\treturn Future.then(right.evaluate(), function (rightEvaluation) {\n\t\t\t\t\tvar comp = mh.problem.compare(left, right);\n\t\t\t\t\tcomp = comp === 0 ? comp : comp > 0 ? 1 : -1;\n\t\t\t\t\t//FIXME Does not support multiobjective optimization.\n\t\t\t\t\treturn (leftEvaluation[0] - rightEvaluation[0]) * comp / 2 / width;\n\t\t\t\t});\n\t\t\t});\n\t\t}));\n\t},\n\n\t/** A gradient estimator at the given `element` for [Simultaneous Perturbation Stochastic\n\tApproximation](http://www.jhuapl.edu/SPSA/).\n\t*/\n\tgradientSimultaneousPerturbation: function gradientSimultaneousPerturbation(width, element) {\n\t\tthrow new Error('GradientDescent.gradientSimultaneousPerturbation() is not implemented!');//TODO\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'GradientDescent',\n\t\tserializer: function serialize_GradientDescent(obj) {\n\t\t\treturn [obj.__params__('delta')];\n\t\t}\n\t}\n}); // declare GradientDescent.\n","/** # _\"Hello World\"_ problem\n\nAs it sounds, `HelloWorld` is a simple problem class, probably only useful for testing purposes.\n*/\nproblems.HelloWorld = declare(Problem, {\n\ttitle: \"Hello world\",\n\tdescription: \"Simple problem where each element is a string, and the \"+\n\t\t\"optimization goes towards the target string.\",\n\n\t/** In this simple problem each element is a string, and the optimization goes towards the\n\ttarget string. The string to match is specified by the `target` parameter (`\"Hello world!\"` by\n\tdefault). Since elements' evaluation is a distance, this value must be minimized to guide the\n\tsearch towards the target string.\n\t*/\n\tconstructor: function HelloWorld(params) {\n\t\t/** The elements' length is equal to the length of the target string. Every value is\n\t\tbetween 32 (inclusive) and 127 (exclusive), which is the range of visible characters in\n\t\tASCII.\n\t\t*/\n\t\tparams = params || {};\n\t\tinitialize(this, params)\n\t\t\t.string('target', { coerce: true, defaultValue: 'Hello world!' });\n\t\tProblem.call(this, Object.assign(params, {\n\t\t\tobjective: -Infinity,\n\t\t\telementModel: Iterable.repeat({ n: 127 - 32 }, this.target.length).toArray()\n\t\t}));\n\t\tthis.__target__ = iterable(this.target).map(function (c) {\n\t\t\treturn c.charCodeAt(0);\n\t\t}).toArray();\n\t},\n\n\t/** An element's values are always numbers. These are converted to a string by converting each\n\tnumber to its corresponding Unicode character.\n\t*/\n\tmapping: function mapping(element) {\n\t\treturn element.values().map(function (v) {\n\t\t\treturn String.fromCharCode(v + 32);\n\t\t}).join('');\n\t},\n\n\t/** An element evaluation is equal to its distance from target string.\n\t*/\n\tevaluation: function evaluation(element) {\n\t\treturn element.manhattanDistance(this.__target__, element.rangeMapping([32, 127]));\n\t},\n\n\t/** An element is sufficient when its equal to the target string.\n\t*/\n\tsufficientElement: function sufficientElement(element) {\n\t\treturn this.mapping(element) === this.target;\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'HelloWorld',\n\t\tserializer: function serialize_HelloWorld(obj) {\n\t\t\treturn [obj.__params__('target')];\n\t\t}\n\t}\n}); // declare HelloWorld.\n","/** # Test beds\n\nProblem builder for test beds of algorithms in this library.\n*/\n\n/** The function `testbed` is a shortcut used to define the test problems.\n*/\nvar TestBed = problems.TestBed = declare(Problem, {\n\tconstructor: function TestBed(spec) {\n\t\tvar minimumValue = isNaN(spec.minimumValue) ? -1e6 : +spec.minimumValue,\n\t\t\tmaximumValue = isNaN(spec.maximumValue) ? +1e6 : +spec.maximumValue,\n\t\t\tlength = isNaN(spec.length) ? 2 : +spec.length;\n\t\tProblem.call(this, base.copy({\n\t\t\ttitle: spec.title,\n\t\t\telementModel: Iterable.repeat({ n: 2e6 }, length).toArray()\n\t\t}, spec));\n\t\tthis.evaluation = function evaluation(element) {\n\t\t\treturn spec.evaluation(element.rangeMapping([minimumValue, maximumValue]));\n\t\t};\n\n\t\t/** If an optimum value is provided (`spec.optimumValue`) it is added to the termination\n\t\tcriteria.\n\t\t*/\n\t\tif (spec.hasOwnProperty('optimumValue')) {\n\t\t\tthis.sufficientElement = function sufficientElement(element) {\n\t\t\t\treturn Math.abs(element.evaluation - spec.optimumValue) < element.resolution;\n\t\t\t};\n\t\t}\n\t}\n});\n\n/** Testbed problems taken from the web (e.g.\n[1](http://en.wikipedia.org/wiki/Test_functions_for_optimization),\n[2](http://www.sfu.ca/~ssurjano/optimization.html),\n[3](http://www-optima.amp.i.kyoto-u.ac.jp/member/student/hedar/Hedar_files/TestGO.htm)\n).\n*/\nproblems.testbeds = {\n\t/** The [Ackley's function](http://www.sfu.ca/~ssurjano/ackley.html) (in 2 dimensions) has an\n\tglobal optimum surrounded by an outer region that is rather flat, yet with many local optima.\n\t*/\n\tAckley: function Ackley(length, a, b, c) {\n\t\ta = isNaN(a) ? 20 : +a;\n\t\tb = isNaN(b) ? 0.2 : +b;\n\t\tc = isNaN(c) ? 2 * Math.PI : +c;\n\t\treturn new TestBed({\n\t\t\ttitle: \"Ackley testbed\",\n\t\t\tlength: length,\n\t\t\tobjectives: -Infinity,\n\t\t\tminimumValue: -32.768,\n\t\t\tmaximumValue: +32.768,\n\t\t\toptimumValue: 0,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar term1 = 0,\n\t\t\t\t\tterm2 = 0,\n\t\t\t\t\td = vs.length,\n\t\t\t\t\tv;\n\t\t\t\tfor (var i = 0; i < d; ++i) {\n\t\t\t\t\tv = vs[i];\n\t\t\t\t\tterm1 += v * v;\n\t\t\t\t\tterm2 += Math.cos(c * v);\n\t\t\t\t}\n\t\t\t\treturn -a * Math.exp(-b * Math.sqrt(term1 / d)) - Math.exp(term2 / d) + a + Math.exp(1);\n\t\t\t}\n\t\t});\n\t},\n\n\t/** The cross-in-tray is a function with many local optima, both minima and maxima. If minimized\n\tit has 4 global minima.\n\t*/\n\tcrossInTray: function crossInTray(target) {\n\t\ttarget = isNaN(target) ? -Infinity : +target;\n\t\treturn new TestBed({\n\t\t\ttitle: \"cross-in-tray testbed\",\n\t\t\tlength: 2,\n\t\t\tobjectives: target,\n\t\t\tminimumValue: -10,\n\t\t\tmaximumValue: +10,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar x = vs[0], y = vs[1];\n\t\t\t\treturn -0.0001 * Math.pow(Math.abs(Math.sin(x) * Math.sin(y) *\n\t\t\t\t\tMath.exp(Math.abs(100 - Math.sqrt(x*x + y*y) / Math.PI))) + 1, 0.1);\n\t\t\t}\n\t\t});\n\t},\n\n\t/** The [Griewank function](http://www.sfu.ca/~ssurjano/griewank.html) has many local optima\n\tregularly distributed.\n\t*/\n\tGriewank: function Griewank(length) {\n\t\treturn new TestBed({\n\t\t\ttitle: \"Griewank testbed\",\n\t\t\tlength: length,\n\t\t\tminimumValue: -600,\n\t\t\tmaximumValue: +600,\n\t\t\toptimumValue: 0,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar sum = 0, prod = 1, len = vs.length, v;\n\t\t\t\tfor (var i = 0; i < len; ++i) {\n\t\t\t\t\tv = vs[i];\n\t\t\t\t\tsum += v * v / 4000;\n\t\t\t\t\tprod *= Math.cos(v / Math.sqrt(i+1));\n\t\t\t\t}\n\t\t\t\treturn sum - prod + 1;\n\t\t\t}\n\t\t});\n\t},\n\n\t/** The [Levy function](http://www.sfu.ca/~ssurjano/levy.html) is multimodal, with some\n\tdifficult local minima regions.\n\t*/\n\tLevy: function Levy(length) {\n\t\treturn new TestBed({\n\t\t\ttitle: \"Levy testbed\",\n\t\t\tlength: length,\n\t\t\tobjectives: -Infinity,\n\t\t\tminimumValue: -10,\n\t\t\tmaximumValue: +10,\n\t\t\toptimumValue: 0,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar sum = 0, d = vs.length,\n\t\t\t\t\tw1 = 1 + (vs[0] - 1) / 4, wd = 1 + (vs[d-1] - 1) / 4, w;\n\t\t\t\tfor (var i = 1; i < d - 1; ++i) {\n\t\t\t\t\tw = 1 + (vs[i] - 1) / 4;\n\t\t\t\t\tsum += Math.pow(w - 1, 2) * (1 + 10 * Math.pow(Math.sin(Math.PI * w + 1), 2));\n\t\t\t\t}\n\t\t\t\treturn Math.pow(Math.sin(Math.PI * w1), 2) + sum +\n\t\t\t\t\tMath.pow(wd - 1, 2) * (1 + Math.pow(Math.sin(2 * Math.PI * wd), 2));\n\t\t\t}\n\t\t});\n\t},\n\n\t/** The [Michalewicz function](http://www.sfu.ca/~ssurjano/michal.html) is a multimodal function\n\twith a number local minima equal to the factorial of the number of dimensions; and it has steep\n\tvalleys and ridges.\n\t*/\n\tMichalewicz: function Michalewicz(length, m) {\n\t\tm = isNaN(m) ? 10 : +m;\n\t\treturn new TestBed({\n\t\t\ttitle: \"Michalewicz testbed\",\n\t\t\tlength: length,\n\t\t\tobjectives: -Infinity,\n\t\t\tminimumValue: 0,\n\t\t\tmaximumValue: Math.PI,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar sum = 0,\n\t\t\t\t\td = vs.length,\n\t\t\t\t\tv;\n\t\t\t\tfor (var i = 0; i < d; ++i) {\n\t\t\t\t\tv = vs[i];\n\t\t\t\t\tsum += Math.sin(v) * Math.pow(Math.sin((i+1) * v * v / Math.PI), 2 * m);\n\t\t\t\t}\n\t\t\t\treturn -sum;\n\t\t\t}\n\t\t});\n\t},\n\n\t/** [Perm(0,d,beta) function](http://www-optima.amp.i.kyoto-u.ac.jp/member/student/hedar/Hedar_files/TestGO_files/Page2545.htm).\n\t*/\n\tperm0: function perm0(d, beta) {\n\t\td = isNaN(d) ? 2 : Math.min(1, d|0);\n\t\tbeta = isNaN(beta) ? 0 : +beta;\n\t\treturn new TestBed({\n\t\t\ttitle: \"Perm(0,\"+ d +\",\"+ beta +\") testbed\",\n\t\t\tlength: d,\n\t\t\tobjectives: -Infinity,\n\t\t\tminimumValue: -d,\n\t\t\tmaximumValue: +d,\n\t\t\toptimumValue: 0,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar sum1 = 0, sum2, v;\n\t\t\t\tfor (var i = 0; i < d; ++i) {\n\t\t\t\t\tsum2 = 0;\n\t\t\t\t\tfor (var j = 0; j < d; ++j) {\n\t\t\t\t\t\tsum2 += (j+1 + beta) * (Math.pow(vs[j], i+1) - Math.pow(1 / (j+1), i+1));\n\t\t\t\t\t}\n\t\t\t\t\tsum1 += sum2 * sum2;\n\t\t\t\t}\n\t\t\t\treturn sum1;\n\t\t\t}\n\t\t});\n\t},\n\n\t/** The [Rastrigin function](http://www.sfu.ca/~ssurjano/rastr.html) is highly multimodal yet\n\tlocal minima are regularly distributed.\n\t*/\n\tRastrigin: function Rastrigin(length) {\n\t\treturn new TestBed({\n\t\t\ttitle: \"Rastrigin testbed\",\n\t\t\tlength: length,\n\t\t\tobjectives: -Infinity,\n\t\t\tminimumValue: -5.12,\n\t\t\tmaximumValue: +5.12,\n\t\t\toptimumValue: 0,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar result = 0, d = vs.length, v;\n\t\t\t\tfor (var i = 0; i < d; ++i) {\n\t\t\t\t\tv = vs[i];\n\t\t\t\t\tresult += v * v - 10 * Math.cos(2 * Math.PI * v);\n\t\t\t\t}\n\t\t\t\treturn 10 * d + result;\n\t\t\t}\n\t\t});\n\t},\n\n\t/*** The [Rosenbrock function](http://en.wikipedia.org/wiki/Rosenbrock_function) is a function\n\tused as a performance test problem for optimization algorithms introduced by Howard H.\n\tRosenbrock in 1960. The global minimum is inside a long, narrow, parabolic shaped flat valley.\n\tTo find the valley is trivial, yet to converge to the global minimum (zero) is difficult.\n\t*/\n\tRosenbrock: function Rosenbrock(length, a, b) {\n\t\ta = isNaN(a) ? 1 : +a;\n\t\tb = isNaN(b) ? 100 : +b;\n\t\treturn new TestBed({\n\t\t\ttitle: \"Rosenbrock testbed\",\n\t\t\tlength: length,\n\t\t\tobjectives: -Infinity,\n\t\t\toptimumValue: 0,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar result = 0;\n\t\t\t\tfor (var i = 1; i < vs.length; ++i) {\n\t\t\t\t\tresult += b * Math.pow(vs[i-1] * vs[i-1] - vs[i], 2) + Math.pow(vs[i-1] - a, 2);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t},\n\n\t/** The [Schwefel function](http://www.sfu.ca/~ssurjano/schwef.html) is a complex test with many\n\tlocal optima.\n\t*/\n\tSchwefel: function Schwefel(length) {\n\t\treturn new TestBed({\n\t\t\ttitle: \"Schwefel testbed\",\n\t\t\tlength: length,\n\t\t\tobjectives: -Infinity,\n\t\t\tminimumValue: -500,\n\t\t\tmaximumValue: +500,\n\t\t\toptimumValue: 0,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar result = 0,\n\t\t\t\t\td = vs.length,\n\t\t\t\t\tv;\n\t\t\t\tfor (var i = 0; i < d; ++i) {\n\t\t\t\t\tv = vs[i];\n\t\t\t\t\tresult += v * Math.sin(Math.sqrt(Math.abs(v)));\n\t\t\t\t}\n\t\t\t\treturn 418.9829 * d - result;\n\t\t\t}\n\t\t});\n\t},\n\n\t/** The [sphere function](http://www.sfu.ca/~ssurjano/spheref.html) minimizes the sum of the\n\tsquares for every value in the input vector. It has as many local minima as dimensions the\n\tsearch space has, but still only one global minimum (zero).\n\t*/\n\tsphere: function sphere(length) {\n\t\treturn new TestBed({\n\t\t\ttitle: \"sphere testbed\",\n\t\t\tlength: length,\n\t\t\tobjectives: -Infinity,\n\t\t\toptimumValue: 0,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar result = 0;\n\t\t\t\tfor (var i = 0; i < vs.length; ++i) {\n\t\t\t\t\tresult += vs[i] * vs[i];\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t},\n\n\t/** A very simple class of problems that deal with optimizing the sum of the elements' values.\n\tProbably the simplest optimization problem that can be defined. It has no local optima, and it\n\tdraws a simple and gentle slope towards to global optimum.\n\t*/\n\tsumOptimization: function sumOptimization(length, target) {\n\t\tlength = isNaN(length) ? 2 : Math.max(1, length|0);\n\t\ttarget = isNaN(target) ? -Infinity : +target;\n\t\treturn new TestBed({\n\t\t\ttitle: \"sum optimization testbed\",\n\t\t\tlength: length,\n\t\t\tobjectives: target,\n\t\t\tminimumValue:  0,\n\t\t\tmaximumValue: +1,\n\t\t\toptimumValue: target === -Infinity ? 0 : target === +Infinity ? length : target,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\treturn iterable(vs).sum();\n\t\t\t}\n\t\t});\n\t},\n\n\t// ## Multi-objective ##########################################################################\n\n\t/** Multiobjective optimization problems taken from [_\"Comparison of Multiobjective Evolutionary\n\tAlgorithms: Empirical Results\"_ by Zitzler, Deb and Thiele (2000)](http://www.tik.ee.ethz.ch/sop/publicationListFiles/zdt2000a.pdf).\n\t*/\n\tZDT1: function ZDT1(length) {\n\t\tlength = isNaN(length) ? 30 : Math.max(1, length|0);\n\t\treturn new TestBed({\n\t\t\ttitle: \"Zitzler-Deb-Thiele function 1\",\n\t\t\tlength: length,\n\t\t\tobjectives: [-Infinity, -Infinity],\n\t\t\tminimumValue:  0,\n\t\t\tmaximumValue: +1,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar f1 = vs[0],\n\t\t\t\t\tg = iterable(vs).tail().sum() / (vs.length - 1) * 9,\n\t\t\t\t\th = 1 - Math.sqrt(f1 / g);\n\t\t\t\treturn [f1, g * h];\n\t\t\t}\n\t\t});\n\t},\n\n\tZDT2: function ZDT2(length) {\n\t\tlength = isNaN(length) ? 30 : Math.max(1, length|0);\n\t\treturn new TestBed({\n\t\t\ttitle: \"Zitzler-Deb-Thiele function 2\",\n\t\t\tlength: length,\n\t\t\tobjectives: [-Infinity, -Infinity],\n\t\t\tminimumValue:  0,\n\t\t\tmaximumValue: +1,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar f1 = vs[0],\n\t\t\t\t\tg = iterable(vs).tail().sum() / (vs.length - 1) * 9,\n\t\t\t\t\th = 1 - Math.pow(f1 / g, 2);\n\t\t\t\treturn [f1, g * h];\n\t\t\t}\n\t\t});\n\t},\n\n\tZDT3: function ZDT3(length) {\n\t\tlength = isNaN(length) ? 30 : Math.max(1, length|0);\n\t\treturn new TestBed({\n\t\t\ttitle: \"Zitzler-Deb-Thiele function 3\",\n\t\t\tlength: length,\n\t\t\tobjectives: [-Infinity, -Infinity],\n\t\t\tminimumValue:  0,\n\t\t\tmaximumValue: +1,\n\t\t\tevaluation: function evaluation(vs) {\n\t\t\t\tvar f1 = vs[0],\n\t\t\t\t\tg = iterable(vs).tail().sum() / (vs.length - 1) * 9,\n\t\t\t\t\th = 1 - Math.sqrt(f1 / g) - (f1 / g) * Math.sin(10 * Math.PI * f1);\n\t\t\t\treturn [f1, g * h];\n\t\t\t}\n\t\t});\n\t}\n}; // problems.testbeds\n","/** # N queens puzzle problem\n\nA generalized version of the classic [8 queens puzzle](http://en.wikipedia.org/wiki/Eight_queens_puzzle),\na problem of placing 8 chess queens on an 8x8 chessboard so that no two queens may attack each\nother.\n*/\nproblems.NQueensPuzzle = declare(Problem, {\n\ttitle: \"N-queens puzzle\",\n\tdescription: \"Generalized version of the classic problem of placing \"+\n\t\t\"8 chess queens on an 8x8 chessboard so that no two queens attack each other.\",\n\n\t/** The constructor takes only one particular parameter:\n\t*/\n\tconstructor: function NQueensPuzzle(params) {\n\t\t/** Since the evaluation is defined as the number of shared diagonals, it must be\n\t\tminimized.\n\t\t*/\n\t\tparams = Object.assign({ N: 8 }, params);\n\t\tProblem.call(this, params = Object.assign(params, {\n\t\t\tobjective: -Infinity,\n\t\t\t/** The representation is an array of `N` positions, indicating the row of the\n\t\t\tqueen for each column.\n\t\t\t*/\n\t\t\telementModel: Iterable.repeat({ n: params.N }, params.N - 1).toArray()\n\t\t}));\n\t\tinitialize(this, params)\n\t\t\t/** + `N=8`: the number of queens and both dimensions of the board.\n\t\t\t*/\n\t\t\t.integer('N', { coerce: true, defaultValue: 8 });\n\t\tthis.__rowRange__ = Iterable.range(this.N).toArray();\n\t},\n\n\tmapping: function mapping(element) {\n\t\treturn element.setMapping(this.__rowRange__);\n\t},\n\n\t/** The elements' evaluation is the count of diagonals shared by queens pairwise.\n\t*/\n\tevaluation: function evaluation(element) {\n\t\tvar rows = this.mapping(element),\n\t\t\tcount = 0;\n\t\trows.forEach(function (row, i) {\n\t\t\tfor (var j = 1; i + j < rows.length; j++) {\n\t\t\t\tif (rows[j] == row + j || rows[j] == row - j) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn count;\n\t},\n\n\t/** It is sufficient when no pair of queens share diagonals.\n\t*/\n\tsufficientElement: function sufficientElement(element) {\n\t\treturn element.evaluation === 0;\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'NQueensPuzzle',\n\t\tserializer: function serialize_NQueensPuzzle(obj) {\n\t\t\treturn [obj.__params__('N')];\n\t\t}\n\t}\n}); // declare NQueensPuzzle\n","/** # Knapsack problem\n\nThe [Knapsack problem](http://en.wikipedia.org/wiki/Knapsack_problem) is a classic combinatorial\noptimization problem. Given a set of items, each with cost and worth, a selection must be obtained\n(to go into the knapsack) so that the total cost does not exceed a certain limit, while maximizing\nthe total worth.\n*/\nproblems.KnapsackProblem = declare(Problem, {\n\ttitle: \"Knapsack problem\",\n\tdescription: \"Given a set of items with a cost and a worth, select a subset \"+\n\t\t\" maximizing the worth sum but not exceeding a cost limit.\",\n\n\t/** `items` is the superset of all candidate solutions. Must be an object with each item by\n\tname. Each item must have a cost and a worth, and may have an amount (1 by default).\n\t*/\n\titems: {\n\t\titemA: { cost: 12, worth:  4 },\n\t\titemB: { cost:  2, worth:  2 },\n\t\titemC: { cost:  1, worth:  2 },\n\t\titemD: { cost:  1, worth:  1 },\n\t\titemE: { cost:  4, worth: 10 }\n\t},\n\n\t/** The problem is based on a given a set of items, each with a cost and a worth. The solution\n\tis a subset of items with maximum worth sum that does not exceed a cost limit.\n\n\tThe parameters specific for this problem are:\n\t*/\n\tconstructor: function KnapsackProblem(params) {\n\t\t/** The problem's representation is an array with a number for each item, in alphabetical\n\t\torder. Each number holds the selected amount for each item (from 0 up to the item's\n\t\tamount).\n\t\t*/\n\t\tparams = params || {};\n\t\tvar items = this.items;\n\t\tthis.__elementItems__ = Object.keys(items);\n\t\tthis.__elementItems__.sort();\n\t\tProblem.call(this, params = Object.assign(params, {\n\t\t\t/** The best selection of items is the one that maximizes worth, without\n\t\t\texceeding the cost limit.\n\t\t\t*/\n\t\t\tobjective: +Infinity,\n\t\t\telementModel: this.__elementItems__.map(function (name) {\n\t\t\t\treturn { n: +(items[name].amount || 1) + 1 };\n\t\t\t})\n\t\t}));\n\t\tinitialize(this, params)\n\t\t\t/** + `limit=15` is the cost limit that candidate solution should not exceed.\n\t\t\t*/\n\t\t\t.number('limit', { coerce: true, defaultValue: 15 })\n\t\t\t/** + `defaultAmount=1` is the amount available for each item by default.\n\t\t\t*/\n\t\t\t.integer('amount', { coerce: true, defaultValue: 1, minimum: 1 })\n\t\t\t/** + `items` is the set of items.\n\t\t\t*/\n\t\t\t.object('items', { ignore: true });\n\t},\n\n\t/** All elements are mapped to an object with the selected amount associated to each item.\n\t*/\n\tmapping: function mapping(element) {\n\t\treturn iterable(this.__elementItems__).zip(element.values()).toObject();\n\t},\n\n\t/** All elements are evaluated by calculating the worth of all included items. If their cost is\n\tgreater than the problem's limit, the worth becomes negative.\n\t*/\n\tevaluation: function evaluation(element) {\n\t\tvar selection = this.mapping(element),\n\t\t\titems = this.items,\n\t\t\tworth = 0,\n\t\t\tcost = 0;\n\t\titerable(selection).forEachApply(function (name, amount) {\n\t\t\tvar item = items[name];\n\t\t\tworth += item.worth * amount;\n\t\t\tcost += item.cost * amount;\n\t\t});\n\t\treturn cost > problem.limit ? -worth : worth; //FIXME Too punishing for going over the limit.\n\t},\n\n\t// ## Utilities ################################################################################\n\n\t/** Serialization and materialization using Sermat.\n\t*/\n\t'static __SERMAT__': {\n\t\tidentifier: 'KnapsackProblem',\n\t\tserializer: function serialize_KnapsackProblem(obj) {\n\t\t\treturn [obj.__params__('limit', 'amount', 'items')];\n\t\t}\n\t}\n}); // declare KnapsackProblem\n","/** # Association rules learning.\n\nAssociation rules are relations between variables found in databases. Many methods have been\nresearched to automatically search for interesting rules in large data sets.\n\nFor further information, see:\n\n+ Agrawal, R.; Imieliski, T.; Swami, A. [_\"Mining association rules between sets of items in large\n\tdatabases\"_](http://dl.acm.org/citation.cfm?doid=170035.170072). Proceedings of the 1993 ACM\n\tSIGMOD international conference on Management of data.\n\n+ Sergey Brin, Rajeev Motwani, Jeffrey D. Ullman, and Shalom Tsur. [_\"Dynamic itemset counting and\n\timplication rules for market basket data\"_](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.3707).\n\tSIGMOD 1997, Proceedings ACM SIGMOD International Conference on Management of Data.\n*/\nvar AssociationRuleLearning = problems.AssociationRuleLearning = declare(Problem, {\n\t/** The constructors take the following parameters:\n\t*/\n\tconstructor: function AssociationRuleLearning(params) {\n\t\tinitialize(this, params)\n\t\t\t/** + A `dataset` with which to test the association rules. It must be a sequence of\n\t\t\trecords (each an object).\n\t\t\t*/\n\t\t\t.object('dataset', { defaultValue: [] })\n\t\t\t/** + A set of `keys` for the fields in the dataset.\n\t\t\t*/\n\t\t\t.array('keys');\n\t\tProblem.call(this, base.copy({\n\t\t\t/** The elements represent classic association rules, which treat each record as a\n\t\t\tset of `keys`. Each position in the element's values tells if the corresponding key\n\t\t\tbelongs to the rule's antecedent or consequent; or neither. Empty antecedents and\n\t\t\tconsequents always evaluate to false.\n\t\t\t*/\n\t\t\telementModel: Iterable.repeat({ n: 3 }, this.keys.length).toArray()\n\t\t}, params));\n\t},\n\n\t// ## Evaluation ###############################################################################\n\n\t/** Turns the element into an association rule, i.e. an object with two disjunct sets of keys:\n\tone for the antecedent and the other for the consequent.\n\t*/\n\tmapping: function mapping(element) {\n\t\tvar problem = this,\n\t\t\tantecedent = [],\n\t\t\tconsequent = [];\n\t\telement.__values__.forEach(function (v, i) {\n\t\t\tswitch (v) {\n\t\t\t\tcase 1: antecedent.push(problem.keys[i]); break;\n\t\t\t\tcase 2: consequent.push(problem.keys[i]); break;\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tantecedent: antecedent,\n\t\t\tconsequent: consequent\n\t\t};\n\t},\n\n\tkeysComply: function keysComply(keys, record) {\n\t\tvar it = iterable(keys);\n\t\treturn !it.isEmpty() && it.all(function (key) {\n\t\t\treturn !!record[key];\n\t\t});\n\t},\n\n\t/** This method checks if the given `record` complies with the given `rule`'s `antecedent`.\n\t*/\n\tantecedentComplies: function antecedentComplies(rule, record) {\n\t\treturn this.keysComply(rule.antecedent, record);\n\t},\n\n\t/** This method checks if the given `record` complies with the given `rule`'s `consequent`.\n\t*/\n\tconsequentComplies: function consequentComplies(rule, record) {\n\t\treturn this.keysComply(rule.consequent, record);\n\t},\n\n\t/** The `measures` of an `element` (representing an association rule) include the usual\n\tstatistics:\n\n\t+ `antecedentCount`, `consequentCount`, `ruleCount` are the numbers of records that comply with\n\t\tthis rules's antecedent, consequent and both.\n\t+ `antecedentSupport`, `consequentSupport`, `ruleSupport` are the same numbers as before but\n\t\tdivided by the total number of records.\n\t+ `confidence` can be interpreted as an estimation of _P(C|A)_ for rules _A -> C_.\n\t+ `lift` is the ratio of the observed support to that expected if A and C were independent.\n\t+ `conviction` is the ratio of the expected frequency that A occurs without C.\n\t+ `leverage` measures the difference of A and C appearing together in the data set and what\n\t\twould be expected if X and Y where statistically dependent.\n\t*/\n\tmeasures: function measures(element) {\n\t\tvar problem = this,\n\t\t\tresult = {},\n\t\t\ttotalCount = 0,\n\t\t\tantecedentCount = 0,\n\t\t\tconsequentCount = 0,\n\t\t\truleCount = 0,\n\t\t\trule = this.mapping(element);\n\t\titerable(this.dataset).forEach(function (record) {\n\t\t\tif (problem.antecedentComplies(rule, record)) {\n\t\t\t\t++antecedentCount;\n\t\t\t\tif (problem.consequentComplies(rule, record)) {\n\t\t\t\t\t++consequentCount;\n\t\t\t\t\t++ruleCount;\n\t\t\t\t}\n\t\t\t} else if (problem.consequentComplies(rule, record)) {\n\t\t\t\t++consequentCount;\n\t\t\t}\n\t\t\t++totalCount;\n\t\t});\n\t\tresult.antecedentCount = antecedentCount;\n\t\tresult.consequentCount = consequentCount;\n\t\tresult.ruleCount = ruleCount;\n\t\tresult.antecedentSupport = totalCount > 0 ? antecedentCount / totalCount : 0;\n\t\tresult.consequentSupport = totalCount > 0 ? consequentCount / totalCount : 0;\n\t\tresult.ruleSupport = totalCount > 0 ? ruleCount / totalCount : 0;\n\t\tresult.confidence = antecedentCount > 0 ? ruleCount / antecedentCount : 0;\n\t\tresult.lift = result.consequentSupport > 0 ? result.confidence / result.consequentSupport : 0;\n\t\tresult.conviction = result.consequentSupport > 0 && result.confidence < 1 ? (1 - result.consequentSupport) / (1 - result.confidence) : 0;\n\t\tresult.leverage = result.ruleSupport - result.antecedentSupport * result.consequentSupport;\n\t\treturn result;\n\t},\n\n\t/** By default, the evaluation uses the rule's confidence. It assumes the elements has a\n\t`dataset` member. Measures are cached in a `__measures__` property in the element.\n\t*/\n\tevaluation: function evaluation(element) {\n\t\tif (!element.__measures__) {\n\t\t\telement.__measures__ = this.measures(element);\n\t\t}\n\t\treturn element.__measures__.confidence;\n\t}\n}); // declare AssociationRule.\n","// See __prologue__.js\n\t[Element, Problem, Metaheuristic,\n\t// metaheuristics.\n\t// problems.\n\t].forEach(function (type) {\n\t\ttype.__SERMAT__.identifier = exports.__package__ +'.'+ type.__SERMAT__.identifier;\n\t\texports.__SERMAT__.include.push(type);\n\t});\n\tSermat.include(exports); // Inveniemus uses Sermat internally.\n\n\treturn exports;\n}\n"]}